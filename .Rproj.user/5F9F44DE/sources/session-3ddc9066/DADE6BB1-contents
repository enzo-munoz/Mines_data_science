# ================================================================================
# EXERCICE 2 : APPLICATION DU MODÈLE ARCH À DES DONNÉES RÉELLES
# ================================================================================

# -------------------------------------------------------------------------
# 0. INSTALLATION ET CHARGEMENT DES PACKAGES
# -------------------------------------------------------------------------

# Packages nécessaires
packages <- c("quantmod", "tseries", "forecast", "rugarch", "FinTS")

# Installer les packages manquants
for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg)
    library(pkg, character.only = TRUE)
  }
}

# -------------------------------------------------------------------------
# 1. IMPORTATION ET PRÉPARATION DES DONNÉES
# -------------------------------------------------------------------------

cat("========================================\n")
cat("ÉTAPE 1 : IMPORTATION DES DONNÉES\n")
cat("========================================\n\n")

# Importer les données de l'or (Gold Futures)
ticker <- "GC=F"
getSymbols(ticker, src = "yahoo", from = "2020-01-01", to = "2024-12-31")

# Extraire les prix de clôture
close_prices <- Cl(get(ticker))
cat("Nombre d'observations :", length(close_prices), "\n")
cat("Période :", as.character(start(close_prices)), "à", as.character(end(close_prices)), "\n\n")

# Calculer les rendements logarithmiques
log_returns <- diff(log(close_prices))
log_returns <- na.omit(log_returns)  # Supprimer les NA

# Statistiques descriptives
cat("Statistiques descriptives des rendements :\n")
cat("  Moyenne :", mean(log_returns), "\n")
cat("  Écart-type :", sd(log_returns), "\n")
cat("  Min :", min(log_returns), "\n")
cat("  Max :", max(log_returns), "\n")
cat("  Skewness :", moments::skewness(as.numeric(log_returns)), "\n")
cat("  Kurtosis :", moments::kurtosis(as.numeric(log_returns)), "\n\n")

# -------------------------------------------------------------------------
# 1.1 DIAGNOSTIC DE L'HÉTÉROSCÉDASTICITÉ
# -------------------------------------------------------------------------

cat("========================================\n")
cat("DIAGNOSTIC DE L'HÉTÉROSCÉDASTICITÉ\n")
cat("========================================\n\n")

# Visualisation graphique
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))

# Graphique 1 : Prix de clôture
plot(close_prices, main = "Prix de l'Or (GC=F)", ylab = "Prix USD", col = "darkgoldenrod2", lwd = 1.5)

# Graphique 2 : Rendements
plot(log_returns, main = "Rendements Logarithmiques", ylab = "Rendements", col = "steelblue", type = "h")

# Graphique 3 : Rendements au carré (indicateur de volatilité)
plot(log_returns^2, main = "Rendements au Carré (Volatilité)", ylab = "Rendements²", col = "red3", type = "h")

# Graphique 4 : Histogramme des rendements
hist(log_returns, breaks = 50, main = "Distribution des Rendements", 
     xlab = "Rendements", col = "lightblue", border = "white")

cat("\n--- 1.1.1 : ACF des Rendements et des Rendements au Carré ---\n\n")

# ACF des rendements
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
acf(log_returns, main = "ACF des Rendements", lag.max = 30)
pacf(log_returns, main = "PACF des Rendements", lag.max = 30)

# ACF des rendements au carré (crucial pour détecter les effets ARCH)
acf(log_returns^2, main = "ACF des Rendements²", lag.max = 30, col = "red")
pacf(log_returns^2, main = "PACF des Rendements²", lag.max = 30, col = "red")

cat("INTERPRÉTATION :\n")
cat("- Si ACF des rendements² montre des autocorrélations significatives,\n")
cat("  cela indique la présence d'hétéroscédasticité (effets ARCH).\n")
cat("- Les pics dans l'ACF des rendements² suggèrent que la volatilité\n")
cat("  passée influence la volatilité actuelle.\n\n")

# -------------------------------------------------------------------------
# 1.2 TESTS FORMELS D'HÉTÉROSCÉDASTICITÉ
# -------------------------------------------------------------------------

cat("--- 1.2 : Tests Formels d'Hétéroscédasticité ---\n\n")

# Test ARCH de Engle (test du multiplicateur de Lagrange)
cat("▶ Test ARCH de Engle (test LM) :\n")
arch_test <- ArchTest(log_returns, lags = 10)
print(arch_test)

cat("\nINTERPRÉTATION du Test ARCH :\n")
cat("- H0 : Pas d'effet ARCH (variance homoscédastique)\n")
cat("- H1 : Présence d'effet ARCH (variance hétéroscédastique)\n")
if (arch_test$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Présence significative d'effets ARCH !\n")
  cat("  → Un modèle ARCH est approprié.\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- CONCLUSION : Pas d'évidence d'effets ARCH significatifs.\n\n")
}

# Test de Ljung-Box sur les rendements au carré
cat("▶ Test de Ljung-Box sur les Rendements² :\n")
lb_test <- Box.test(log_returns^2, type = "Ljung-Box", lag = 10)
print(lb_test)

cat("\nINTERPRÉTATION du Test de Ljung-Box (rendements²) :\n")
cat("- H0 : Pas d'autocorrélation dans les rendements²\n")
if (lb_test$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Les rendements² sont autocorrélés.\n")
  cat("  → Cela confirme l'hétéroscédasticité conditionnelle (effets ARCH).\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n\n")
}

# -------------------------------------------------------------------------
# 2. ESTIMATION D'UN MODÈLE ARCH(1)
# -------------------------------------------------------------------------

cat("========================================\n")
cat("ÉTAPE 2 : ESTIMATION DU MODÈLE ARCH(1)\n")
cat("========================================\n\n")

cat("Le modèle ARCH(1) s'écrit :\n")
cat("  r_t = μ + ε_t\n")
cat("  ε_t = σ_t * z_t,  où z_t ~ N(0,1)\n")
cat("  σ_t² = ω + α₁ * ε²_(t-1)\n\n")

cat("Paramètres à estimer :\n")
cat("  - μ (mu) : moyenne des rendements\n")
cat("  - ω (omega) : constante de la variance (doit être > 0)\n")
cat("  - α₁ (alpha1) : coefficient ARCH (doit être > 0)\n\n")

# Spécification du modèle ARCH(1)
# Modèle pour la moyenne : constante uniquement (ARMA(0,0))
# Modèle pour la variance : ARCH(1) (équivaut à GARCH(1,0))
spec_arch1 <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 0)),  # ARCH(1) = GARCH(1,0)
  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
  distribution.model = "norm"
)

# Essayer avec différents solveurs et options
fit_arch1 <- tryCatch({
  # Tentative 1 : solver "hybrid" (plus robuste)
  ugarchfit(spec = spec_arch1, data = log_returns, solver = "hybrid")
}, error = function(e) {
  cat("Échec avec solver hybrid, essai avec solnp...\n")
  tryCatch({
    # Tentative 2 : solver "solnp" (par défaut mais avec plus d'itérations)
    ugarchfit(spec = spec_arch1, data = log_returns, 
              solver = "solnp",
              solver.control = list(trace = 0, tol = 1e-6, delta = 1e-9))
  }, error = function(e2) {
    cat("Échec avec solnp, essai avec nlminb...\n")
    # Tentative 3 : solver "nlminb"
    ugarchfit(spec = spec_arch1, data = log_returns, solver = "nlminb")
  })
})

# Vérifier la convergence
if (convergence(fit_arch1) != 0) {
  cat("\n⚠️  ATTENTION : Le modèle n'a pas parfaitement convergé.\n")
  cat("Code de convergence :", convergence(fit_arch1), "\n")
  cat("Essayons une approche alternative...\n\n")
  
  # SOLUTION 2 : Utiliser le package fGarch (plus stable pour ARCH pur)
  if (!require("fGarch")) install.packages("fGarch")
  library(fGarch)
  
  cat("Estimation avec le package fGarch...\n")
  # Convertir en vecteur numérique
  returns_vec <- as.numeric(log_returns)
  
  # Estimer ARCH(1) avec fGarch
  fit_arch1_alt <- garchFit(~ garch(1, 0), data = returns_vec, trace = FALSE)
  
  cat("\n========================================\n")
  cat("RÉSULTATS DU MODÈLE ARCH(1) - fGarch\n")
  cat("========================================\n")
  print(summary(fit_arch1_alt))
  
  # Utiliser ce modèle pour la suite
  use_fgarch <- TRUE
} else {
  cat("\n✓ Le modèle a convergé avec succès !\n\n")
  use_fgarch <- FALSE
}

cat("\n========================================\n")
cat("RÉSULTATS DU MODÈLE ARCH(1)\n")
cat("========================================\n")
print(fit_arch1)


# Extraction des coefficients
coefs <- coef(fit_arch1)
cat("\n--- Coefficients Estimés ---\n")
cat("μ (mu)     :", coefs["mu"], "\n")
cat("ω (omega)  :", coefs["omega"], "\n")
cat("α₁ (alpha1):", coefs["alpha1"], "\n\n")

cat("--- Interprétation des Coefficients ---\n\n")

cat("1. ω (omega) = ", coefs["omega"], "\n")
cat("   → Variance inconditionnelle de base.\n")
cat("   → Doit être strictement positif (condition de positivité).\n")
if (coefs["omega"] > 0) {
  cat("   ✓ Condition respectée.\n\n")
} else {
  cat("   ✗ ATTENTION : omega négatif ! Modèle invalide.\n\n")
}

cat("2. α₁ (alpha1) = ", coefs["alpha1"], "\n")
cat("   → Mesure la persistance de la volatilité.\n")
cat("   → Plus α₁ est proche de 1, plus les chocs passés ont un impact durable.\n")
cat("   → Doit être dans [0, 1] pour la stationnarité.\n")
if (coefs["alpha1"] >= 0 && coefs["alpha1"] < 1) {
  cat("   ✓ Condition de stationnarité respectée.\n")
} else if (coefs["alpha1"] >= 1) {
  cat("   ✗ ATTENTION : α₁ ≥ 1, le processus est non-stationnaire !\n")
} else {
  cat("   ✗ ATTENTION : α₁ < 0, condition de positivité non respectée !\n")
}

cat("\n3. Variance Inconditionnelle :\n")
var_incond <- coefs["omega"] / (1 - coefs["alpha1"])
cat("   V(ε_t) = ω / (1 - α₁) = ", var_incond, "\n")
cat("   Écart-type inconditionnel = ", sqrt(var_incond), "\n\n")

# Extraction de la volatilité conditionnelle estimée
sigma_t <- sigma(fit_arch1)

# Graphique de la volatilité conditionnelle
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
plot(log_returns, main = "Rendements de l'Or", ylab = "Rendements", col = "steelblue", type = "h")
plot(sigma_t, main = "Volatilité Conditionnelle Estimée (σ_t)", 
     ylab = "Volatilité", col = "red3", lwd = 1.5)

cat("\nLa volatilité conditionnelle varie dans le temps et capte les périodes\n")
cat("de forte et faible volatilité dans les données.\n\n")

# -------------------------------------------------------------------------
# 3. ANALYSE DES RÉSIDUS
# -------------------------------------------------------------------------

cat("========================================\n")
cat("ÉTAPE 3 : ANALYSE DES RÉSIDUS\n")
cat("========================================\n\n")

cat("Objectif : Vérifier que le modèle ARCH(1) a bien capturé\n")
cat("           toute l'hétéroscédasticité présente dans les données.\n\n")

# Extraction des résidus standardisés
residus_std <- residuals(fit_arch1, standardize = TRUE)

cat("--- 3.1 : Statistiques Descriptives des Résidus Standardisés ---\n\n")
cat("Les résidus standardisés doivent se comporter comme un bruit blanc :\n")
cat("  - Moyenne proche de 0\n")
cat("  - Écart-type proche de 1\n")
cat("  - Pas d'autocorrélation\n\n")

cat("Moyenne des résidus :", mean(residus_std), "\n")
cat("Écart-type des résidus :", sd(residus_std), "\n")
cat("Min :", min(residus_std), "\n")
cat("Max :", max(residus_std), "\n\n")

# Graphiques diagnostiques
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))

# 1. Résidus standardisés dans le temps
plot(residus_std, main = "Résidus Standardisés", ylab = "Résidus", col = "darkgreen", type = "h")
abline(h = 0, col = "red", lty = 2)

# 2. Histogramme
hist(residus_std, breaks = 50, main = "Distribution des Résidus", 
     xlab = "Résidus Standardisés", col = "lightgreen", border = "white", probability = TRUE)
curve(dnorm(x, mean = mean(residus_std), sd = sd(residus_std)), add = TRUE, col = "red", lwd = 2)

# 3. QQ-plot
qqnorm(residus_std, main = "QQ-Plot des Résidus")
qqline(residus_std, col = "red", lwd = 2)

# 4. Résidus² dans le temps
plot(residus_std^2, main = "Résidus Standardisés au Carré", ylab = "Résidus²", col = "purple", type = "h")

cat("--- 3.2 : Tests d'Autocorrélation des Résidus ---\n\n")

# ACF et PACF des résidus standardisés
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
acf(residus_std, main = "ACF des Résidus Standardisés", lag.max = 30)
pacf(residus_std, main = "PACF des Résidus Standardisés", lag.max = 30)
acf(residus_std^2, main = "ACF des Résidus² Standardisés", lag.max = 30, col = "purple")
pacf(residus_std^2, main = "PACF des Résidus² Standardisés", lag.max = 30, col = "purple")

cat("▶ Test de Ljung-Box sur les Résidus Standardisés :\n")
lb_residus <- Box.test(residus_std, type = "Ljung-Box", lag = 10)
print(lb_residus)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'autocorrélation dans les résidus\n")
if (lb_residus$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Les résidus sont un bruit blanc (pas de structure autocorrélée).\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Il reste de l'autocorrélation dans les résidus.\n")
  cat("  → Le modèle pourrait être amélioré (ARMA + ARCH).\n\n")
}

# Test de Ljung-Box sur les résidus au carré
cat("▶ Test de Ljung-Box sur les Résidus² Standardisés :\n")
lb_residus2 <- Box.test(residus_std^2, type = "Ljung-Box", lag = 10)
print(lb_residus2)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'autocorrélation dans les résidus²\n")
if (lb_residus2$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Le modèle ARCH(1) a bien capturé l'hétéroscédasticité.\n")
  cat("  → Pas d'effet ARCH résiduel détecté.\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Il reste de l'hétéroscédasticité dans les résidus.\n")
  cat("  → Un modèle ARCH d'ordre supérieur ou GARCH pourrait être nécessaire.\n\n")
}

# Test ARCH sur les résidus
cat("▶ Test ARCH sur les Résidus Standardisés :\n")
arch_test_residus <- ArchTest(residus_std, lags = 10)
print(arch_test_residus)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'effet ARCH résiduel\n")
if (arch_test_residus$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Pas d'effet ARCH résiduel ! Le modèle est adéquat.\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Des effets ARCH résiduels persistent.\n")
  cat("  → Envisager un modèle GARCH(p,q) avec p,q > 1.\n\n")
}

cat("========================================\n")
cat("CONCLUSION GÉNÉRALE\n")
cat("========================================\n\n")

cat("1. Les données de l'or présentent de l'hétéroscédasticité conditionnelle,\n")
cat("   ce qui justifie l'utilisation d'un modèle ARCH.\n\n")

cat("2. Le modèle ARCH(1) estime une volatilité conditionnelle qui varie\n")
cat("   dans le temps en fonction des chocs passés.\n\n")

cat("3. L'analyse des résidus permet de valider si le modèle a bien capturé\n")
cat("   toute la structure de dépendance dans la variance.\n\n")

if (lb_residus2$p.value > 0.05 && arch_test_residus$p.value > 0.05) {
  cat("✓ Le modèle ARCH(1) semble ADÉQUAT pour ces données.\n\n")
} else {
  cat("⚠ Le modèle pourrait être amélioré (essayer GARCH(1,1) ou ARCH(p) avec p>1).\n\n")
}

cat("========================================\n")
cat("FIN DE L'ANALYSE\n")
cat("========================================\n")

