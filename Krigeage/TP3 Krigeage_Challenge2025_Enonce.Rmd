---
title: "TP3 Krigeage - Challenge 2025-2026"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Ce TP fera l’objet d’un compte-rendu par groupe de 3 à 5 personnes,
sous forme de Rmd + version pdf ou html. Ce compte-rendu servira à l’évaluation. Il est à remettre sur Campus (au lien de rendu TP) avant le 10 janvier 2026 à 23h59.
A titre indicatif, le temps à consacrer à ce TP hors cours est de deux à quatre heures par personne.

# Question 1. Vos noms

```{r}
#1. MUNOZ Enzo 
#2. MUNIER Hugo
#3. GUILBAUD Maxime
```

L'ordre n'a pas d'importance, mais la personne en position 1 sera celle qui remettra le TP sur Campus. Merci de n'opérer qu'une seule remise par groupe! Merci de nommer vos fichiers en faisant apparaître le premier nom, par exemple ici: `TPXXX_GroupeDURAND.Rmd`, `TPXXX_GroupeDURAND.html`

# Question 2. Votre prédiction


```{r seed}
set.seed(123456)
library(DiceKriging)
```


```{r}

Observations = read.csv("defi_observations.csv", header = TRUE)
X<- Observations[,-8]
Y<- Observations[,8]
n<- length(Y)
d<- length(X)

X_new = read.csv("defi_apredire.csv", header = TRUE)
```


```{r}
pairs(X)
```


```{r}
plot(X[,2], Y)
```
# Krigage Simple

```{r}
theta<- 1
sigma2<- 1
monModele <- km(formula = ~1, design = X, response = Y, covtype = "gauss", coef.trend = 0, coef.cov = theta, coef.var = sigma2)
```

# Validation croisée

```{r}
split <- sample(1:n, size = round(0.2 * n))

Xtrain <- X[-split, ]
Xtest  <- X[split, ]

Ytrain <- Y[-split]
Ytest  <- Y[split]

crossValidationError <- function(famille, theta) {

    monModele <- km(formula = ~1, design = Xtrain, response = Ytrain, covtype = famille, coef.trend = 0,  coef.cov = theta, coef.var = 1)
  prediction <- predict(object = monModele, newdata = Xtest , type="SK" , checkNames=FALSE, se.compute=FALSE)  

  error =  (mean((prediction$mean -Ytest)^2))   
  
  return(error)
}
theta<- rep(1, 7)
essai <- crossValidationError("matern3_2", theta)
message("erreur =", essai)

```

```{r}
crossValidationErrorOnVector <- Vectorize(crossValidationError, "theta")

thetaRange <- rep(seq(0.4, 5, length.out = 10), 7)
errors <- crossValidationErrorOnVector("matern3_2",thetaRange)
plot(thetaRange, (errors), type="l")

#optimalTheta = thetaRange[(errors-min(errors)<1e-16)]
optimalTheta = thetaRange[which.min(errors)]
abline(v=optimalTheta, col="red")
title(main = paste("optimalTheta = ", optimalTheta))
```


Vous trouverez dans le répertoire de Campus un fichier intitulé "defi_observations.csv", il comporte des observations pour 7 variables X1, ..., X7, et une variable à prédire Y.

Vous trouverez également dans le répertoire du cours un fichier intitulé "defi_apredire.csv" comportant des valeurs pour les 6 variables X1, ..., X7, et où il faudra prédire Y.

* Remettre vos prédictions dans un fichier csv comportant les 7 variables X1, ..., X7, et la colonne Y prédite. Votre fichier s'intitulera "DefiGroupeXXX" où vous remplacerez le suffixe XXX par le nom de la personne indiquée en position 1 à la question 1, celle qui remettra le TP sur Campus.
Pour l'exemple ci-dessus le nom du fichier serait "DefiGroupeDURAND.csv". Merci de nommer les variables X1, ..., X7 et Y pour la colonne prédite.

* Le programme à l'origine de vos prédictions sera initulé "programmeDefiGroupeXXX" (en remplaçant XXX...). Il est attendu un programme sour format Rmd+ sortie Html ou pdf correspondante (bouton Knit, ou bien Python+Jupyter Notebook avec sortie html ou pdf).

La contrainte: la prédiction doit se faire au moyen du Krigeage (eh oui, c'est un TP de Krigeage), mais vous pouvez utiliser des éléments de régression aussi (cf. Krigeage universel).

ATTENTION! il vous faudra faire attention à bien utiliser une graine pour votre générateur aéatoire, si vous en utilisez un, p.ex `set.seed(123456)` de façon à ce que vos résultats soit reproductibles. D'une exécution à l'autre, votre programme doit proposer LA MEME prédiction!

Vérifiez bien que votre fichier "DefiGroupeXXX.csv" comporte bien le bon nombre de lignes, et des abscisses dans le bon ordre!

Veillez à remettre impérativement ces trois fichiers:

* Le fichier CSV DefiGroupeXXX.csv
* Un notebook Rmd (ou jupyter)
* la sortie html ou pdf correspondante (bouton knit) faisant tourner votre programme


```{r import export données}
# ce qui est donné:

# Votre prédiction; faites mieux, hein ;-)
Y = Apredire$X1 + mean(Observations$Y)
# votre Y prédit ici X1 + la moyenne des Y, c'est très mauvais!

# Votre exportation
# On concatène d'abord les X avec le Y prédit à l'aide de cbind
MonFichierSoumis =  cbind(Apredire, Y)

# puis on exporte
MonNomDeFichier = "DefiGroupeDURAND.csv" # nom de fichier à adapter hein!!!
write.csv(MonFichierSoumis, MonNomDeFichier, row.names = FALSE)

#on vérifie que c'est bien lisible
LectureDeMonFichier = read.csv(MonNomDeFichier, header = TRUE)

#on fait des vérifications élémentaires, bon nombre de lignes, de colonnes, etc.
#on ne doit voir apparaître que des TRUE, sinon ce n'est pas bon!
message(nrow(LectureDeMonFichier) == 100, ": bon nombre de lignes")
message(ncol(LectureDeMonFichier) == 8, ": bon nombre de colonnes")
message(abs(LectureDeMonFichier[37,3]-Apredire[37,3])<1e-6, ": X3 semble ok pour la ligne 37")
message(sum(colnames(LectureDeMonFichier)==c("X1", "X2", "X3", "X4", "X5", "X6", "X7", "Y")) == 8, ": les colonnes sont bien nommées")
```

Voilà, c'est à vous, vous n'avez plus qu'à faire vos prédictions! en remplaçant la ligne `Y = Apredire$X1 + mean(Observations$Y)` bien sûr!

Bon courage!

