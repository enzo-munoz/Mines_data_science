---
title: "tp_serie_temporelle"
output:
  html_document: default
  pdf_document: default
date: "2025-10-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Contexte du TP


```{r, echo=FALSE}
# Gestion des données
if (!require("dplyr")) install.packages("dplyr")
if (!require("tidyr")) install.packages("tidyr")
if (!require("lubridate")) install.packages("lubridate")

# Séries temporelles
if (!require("forecast")) install.packages("forecast")
if (!require("tseries")) install.packages("tseries")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("gridExtra")) install.packages("gridExtra")
if (!require("TSstudio")) install.packages("TSstudio")

# Statistiques descriptives
if (!require("moments")) install.packages("moments")
if (!require("psych")) install.packages("psych")

library(dplyr)
library(tidyr)
library(lubridate)
library(forecast)
library(tseries)
library(ggplot2)
library(gridExtra)
library(moments)
library(psych)

```

```{r, echo = FALSE}

data <- read.csv("data.csv", stringsAsFactors = FALSE)

#head(data)
#str(data)

data$temp_C <- (data$TAVG..Degrees.Fahrenheit. - 32)/1.8

#head(data[,c("TAVG..Degrees.Fahrenheit.","temp_C")])

data$Date <- as.Date(data$Date, format="%m/%d/%Y") #Convertir la colonne en objet Date

data_mensuelle <- data %>%
  mutate (mois = floor_date(Date, "month")) %>%
  group_by(mois) %>%
  summarise(T_moy = mean(temp_C, na.rm = TRUE))

head(data_mensuelle)

```

```{r, echo = FALSE}

temperature <- (ts(data_mensuelle$T_moy, start = c(1990,1), frequency = 12))
moyenne <- mean(temperature, na.rm = TRUE)
mediane <- median(temperature, na.rm = TRUE)
variance <- var(temperature, , na.rm = TRUE)
asymetrie <- skewness(temperature, na.rm = TRUE)
aplatissement <- kurtosis(temperature, na.rm = TRUE)


```

```{r, echo = FALSE}
cat("\nStatistiques descriptives de la série temporelle :\n")
cat("------------------------------------------------\n")
cat("Moyenne :", round(moyenne, 3), "\n")
cat("Médiane :", round(mediane, 3), "\n")
cat("Variance :", round(variance, 3), "\n")
cat("Skewness :", round(skewness, 3), "\n")
cat("Kurtosis :", round(kurtosis, 3), "\n")
```


```{r, echo = FALSE}
plot(temperature,
     main = " Température moyenne mensuelle à Lyon",
     xlab = "Année",
     ylab = "Température (°C)",
     col = "blue",
     lwd = 2)
grid()
mu<- mean(temperature)

abline(h = mu, col = "red", lty = 2, lwd = 2)
legend("topleft", legend = "Moyenne", col = "red", lty = 2, lwd = 2, bty = "n")

```

#La série temporelle présente une moyenne d’environ 13,2°C et une médiane proche (12,6°C), ce qui suggère une distribution globalement symétrique. 
#La variance (47,2) indique une dispersion modérée des valeurs autour de la moyenne, avec un écart-type d’environ 7°C. 
#Le skewness proche de zéro (0,04) confirme l’absence d’asymétrie marquée, 
#tandis que le kurtosis inférieur à 3 (1,79) traduit une distribution plus aplatie que la normale, avec moins de valeurs extrêmes.

#La série présente une forte saisonnalité annuelle (été chaud, hiver froid), avec une amplitude assez stable (~20°C). 
#On peut suspecter une tendance légèrement haussière des températures maximales récentes, mais ce n’est pas flagrant visuellement. 

```{r, echo=FALSE}
# Extraire les mois (1 à 12)
months <- cycle(temperature)

df <- data.frame(Month = factor(months, levels = 1:12, labels = month.abb),
                 Temp = as.numeric(temperature))

# Tracer les boxplots par mois
ggplot(df, aes(x = Month, y = Temp)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Distribution des températures par mois",
       x = "Mois",
       y = "Température (°C)") +
  theme_minimal()

ecart_type_par_mois <- df %>%
  group_by(Month) %>%
  summarise(Ecart_Type_Temp = sd(Temp))

# Création du graphique
ggplot(data = ecart_type_par_mois, aes(x = Month, y = Ecart_Type_Temp)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
    title = "Écart type mensuel des températures",
    x = "Mois",
    y = "Écart type des températures"
  ) +
  theme_minimal()

ecart_type_par_mois
```
#La volatilité dépend du mois étudié. Sur le graphe on voit l'hétéroscélasticité des températures, notament un écart type plus important pour le mois de Janvier avec un écart type de 1.876471°C ou Février avec 2.472963°c contre un écart type de température plus faible pour les mois de Mars ou Avril (1.350898°C resp. 1.497665°C) par exemple.

```{r, echo=FALSE}

op <- par(mfrow = c(1,2))
ro <- acf(ts_temp, lag=15, ylim = c(-1,1), main = "ACF empirique")
alpha <- pacf(ts_temp, lag=15, ylim = c(-1,1), main = "et PACF", xlim=c(0,15))
par(op)

```
La série temporelle n'est pas stationnaire 
```{r, echo=FALSE}
# Différenciation simple
ts_diff1 <- diff(ts_temp, differences = 1)

# Différenciation saisonnière
ts_diff_seas <- diff(ts_temp, lag = 12)

# Tests sur séries différenciées
par(mfrow = c(2, 2))
plot(ts_temp, main = "Série Originale", ylab = "Température", col = "blue", lwd = 1.5)
plot(ts_diff1, main = "Différenciation d = 1", ylab = "Diff(Température)", col = "red", lwd = 1.5)
abline(h = 0, lty = 2)
plot(ts_diff_seas, main = "Différenciation Saisonnière (lag=12)", 
     ylab = "Diff(Température)", col = "green4", lwd = 1.5)
abline(h = 0, lty = 2)

# ACF de la série différenciée
acf(ts_diff1, main = "ACF - Série Différenciée (d=1)", lag.max = 36)

# Test ADF sur série différenciée
adf_diff <- adf.test(ts_diff1)
cat("\nTest ADF après différenciation (d=1) :\n")
cat("p-value :", round(adf_diff$p.value, 4), "\n")
```
La différentiationd'ordre 1 n'est pas satisfaisante. Regardons avec lag 12. 
```{r, echo=FALSE}
des_data<- diff(ts_temp, lag=12)
plot(des_data, type='o', main = "Série désaisonnalisée par différenciation (lag 12)")
mu <- mean(des_data)
sig.des_data <- sd(des_data)
abline(h=mu, col="red", lwd=2)
abline(h=mu+2*sig.des_data, col="red", lwd=2,lty=2)
abline(h=mu-2*sig.des_data, col="red", lwd=2,lty=2)
grid()

```

```{r, echo=FALSE}
op <- par(mfrow = c(1,2))
ro <- acf(des_data, lag=15, ylim = c(-1,1), main = "ACF empirique")
alpha <- pacf(des_data, lag=15, ylim = c(-1,1), main = "et PACF", xlim=c(0,15))
par(op)
```
8.Test de stationnarité
```{r, echo=FALSE}

adf_test <- adf.test(des_data, alternative = "stationary")

print(adf_test)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : la série n'est pas Stationnaire\n")
if (adf_test$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✗ La série n'est pas stationnaire\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✓ La série est stationnaire.\n")
}

```
```{r, echo=FALSE}
# Test KPSS
kpss_result <- kpss.test(des_data)
cat("\nTest KPSS sur la série brute :\n")
cat("-------------------------------\n")
cat("Statistique KPSS :", round(kpss_result$statistic, 4), "\n")
cat("p-value :", round(kpss_result$p.value, 4), "\n\n")

if (kpss_result$p.value < 0.05) {
  cat("✗ La série est NON-STATIONNAIRE (p < 0.05)\n")
} else {
  cat("✓ La série est STATIONNAIRE (p ≥ 0.05)\n")
}
```
Partie 2 : Modélisation et analyse 
```{r}
# Sélection automatique avec auto.arima
cat("Sélection automatique du meilleur modèle ARIMA...\n\n")

fit_auto <- auto.arima(des_data,
                       seasonal = TRUE,
                       stepwise = FALSE,
                       approximation = FALSE,
                       trace = TRUE,
                       ic = "aicc")

cat("\n========================================\n")
cat("MEILLEUR MODÈLE SÉLECTIONNÉ\n")
cat("========================================\n")
print(summary(fit_auto))
```
```{r}
# Tester plusieurs modèles manuellement
models <- list(
  "ARIMA(1,1,1)(1,1,1)[12]" = Arima(des_data, order = c(1,0,1), seasonal = c(1,1,1)),
  "ARIMA(2,1,2)(1,1,1)[12]" = Arima(des_data, order = c(2,0,2), seasonal = c(1,1,1)),
  "ARIMA(1,1,2)(2,1,1)[12]" = Arima(des_data, order = c(1,0,2), seasonal = c(2,1,1)),
  "ARIMA(1,1,2)(2,1,1)[12]" = Arima(des_data, order = c(1,0,2), seasonal = c(2,1,1))
)

# Comparaison des critères
comparison <- data.frame(
  Modèle = names(models),
  AIC = sapply(models, AIC),
  BIC = sapply(models, BIC),
  AICc = sapply(models, function(m) m$aicc),
  LogLik = sapply(models, logLik)
)

comparison <- rbind(
  data.frame(
    Modèle = "Auto ARIMA",
    AIC = AIC(fit_auto),
    BIC = BIC(fit_auto),
    AICc = fit_auto$aicc,
    LogLik = logLik(fit_auto)
  ),
  comparison
)


comparison <- comparison %>% arrange(AICc)

knitr::kable(comparison, 
             caption = "Comparaison des Modèles ARIMA",
             digits = 2)

cat("\n✓ Le meilleur modèle selon AICc est :", comparison$Modèle[1], "\n")
```

```{r}
# Utiliser le modèle auto.arima
checkresiduals(fit_auto)

# Tests supplémentaires
cat("\n--- Tests Complémentaires sur les Résidus ---\n\n")

# Test de Ljung-Box
residus <- residuals(fit_auto)
ljung_box <- Box.test(residus, lag = 20, type = "Ljung-Box")
cat("Test de Ljung-Box (H0 : pas d'autocorrélation) :\n")
cat("  p-value =", round(ljung_box$p.value, 4), "\n")
if (ljung_box$p.value > 0.05) {
  cat("  ✓ Les résidus sont un bruit blanc (p > 0.05)\n\n")
} else {
  cat("  ✗ Autocorrélation résiduelle détectée (p < 0.05)\n\n")
}

# Test de Shapiro-Wilk (normalité)
shapiro_test <- shapiro.test(residus)
cat("Test de Shapiro-Wilk (H0 : normalité) :\n")
cat("  p-value =", round(shapiro_test$p.value, 4), "\n")
if (shapiro_test$p.value > 0.05) {
  cat("  ✓ Les résidus suivent une loi normale (p > 0.05)\n\n")
} else {
  cat("  ✗ Les résidus ne suivent pas une loi normale (p < 0.05)\n\n")
}
```
```{r}
# Analyse détaillée des résidus
par(mfrow = c(2, 3))

# 1. Résidus dans le temps
plot(residus, main = "Résidus du Modèle", ylab = "Résidus", col = "steelblue", type = "l")
abline(h = 0, col = "red", lty = 2, lwd = 2)

# 2. ACF des résidus
acf(residus, main = "ACF des Résidus", lag.max = 36)

# 3. PACF des résidus
pacf(residus, main = "PACF des Résidus", lag.max = 36)

# 4. Histogramme
hist(residus, breaks = 30, main = "Distribution des Résidus",
     xlab = "Résidus", col = "lightblue", border = "white", probability = TRUE)
curve(dnorm(x, mean = mean(residus), sd = sd(residus)), add = TRUE, col = "red", lwd = 2)

# 5. QQ-plot
qqnorm(residus, main = "QQ-Plot des Résidus")
qqline(residus, col = "red", lwd = 2)

# 6. Résidus carrés (hétéroscédasticité)
plot(residus^2, main = "Résidus au Carré", ylab = "Résidus²", col = "purple", type = "h")
abline(h = mean(residus^2), col = "red", lty = 2)
```
```{r}
# Prévisions 12 mois
forecast_12 <- forecast(fit_auto, h = 12)

# Visualisation
plot(forecast_12,
     main = "Prévisions de Température (12 mois)",
     ylab = "Température (°C)",
     xlab = "Année",
     col = "steelblue",
     lwd = 2,
     shadecols = c("lightblue", "lightgray"))
legend("topleft", 
       legend = c("Observé", "Prévision", "IC 80%", "IC 95%"),
       col = c("steelblue", "blue", "lightblue", "lightgray"),
       lwd = c(2, 2, 10, 10),
       bty = "n")

# Tableau des prévisions
forecast_df <- data.frame(
  Mois = 1:12,
  Prévision = round(forecast_12$mean, 2),
  IC_Inf_95 = round(forecast_12$lower[, 2], 2),
  IC_Sup_95 = round(forecast_12$upper[, 2], 2)
)

knitr::kable(forecast_df,
             caption = "Prévisions Mensuelles (12 prochains mois)",
             col.names = c("Mois", "Prévision (°C)", "IC Inf 95%", "IC Sup 95%"))
```
```{r}
# Prévisions 24 mois
forecast_24 <- forecast(fit_auto, h = 12)

plot(forecast_24,
     main = "Prévisions de Température (24 mois)",
     ylab = "Température (°C)",
     xlab = "Année",
     col = "steelblue",
     lwd = 2,
     shadecols = c("lightblue", "lightgray"))
```
A 24 moi il y des problèmes !! il faut garder h = 12
Backtest ? 
```{r}
# Validation croisée temporelle
# Garder les 12 derniers mois comme test
n_test <- 12
ts_train <- window(des_data, end = time(des_data)[length(ts_temp) - n_test])
ts_test <- window(des_data, start = time(des_data)[length(ts_temp) - n_test + 1])

# Réestimer le modèle sur train
fit_train <- auto.arima(ts_train, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)

# Prévisions
forecast_test <- forecast(fit_train, h = n_test)

# Calculer les erreurs
errors <- ts_test - forecast_test$mean
mae <- mean(abs(errors))
rmse <- sqrt(mean(errors^2))
mape <- mean(abs(errors / ts_test)) * 100

cat("Métriques de Performance (Backtesting) :\n")
cat("----------------------------------------\n")
cat("MAE  (Mean Absolute Error)       :", round(mae, 4), "°C\n")
cat("RMSE (Root Mean Squared Error)   :", round(rmse, 4), "°C\n")
cat("MAPE (Mean Absolute Percentage Error) :", round(mape, 2), "%\n")

# Visualisation
plot(des_data, main = "Validation Croisée : Prévisions vs Réalisations",
     ylab = "Température (°C)", col = "black", lwd = 1.5)
lines(forecast_test$mean, col = "red", lwd = 2)
lines(forecast_test$lower[, 2], col = "blue", lty = 2)
lines(forecast_test$upper[, 2], col = "blue", lty = 2)
legend("topleft",
       legend = c("Observé", "Prévision", "IC 95%"),
       col = c("black", "red", "blue"),
       lwd = c(1.5, 2, 1),
       lty = c(1, 1, 2),
       bty = "n")
```
