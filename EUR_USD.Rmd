---
title: "EUR/USD"
output: html_document
date: "2025-10-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


```{r}
# Packages nécessaires
packages <- c("quantmod", "tseries", "forecast", "rugarch", "FinTS")

# Installer les packages manquants
for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg)
    library(pkg, character.only = TRUE)
  }
}
```
```{r, echo=FALSE}
# Gestion des données
if (!require("dplyr")) install.packages("dplyr")
if (!require("tidyr")) install.packages("tidyr")
if (!require("lubridate")) install.packages("lubridate")

# Séries temporelles
if (!require("forecast")) install.packages("forecast")
if (!require("tseries")) install.packages("tseries")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("gridExtra")) install.packages("gridExtra")
if (!require("TSstudio")) install.packages("TSstudio")

# Statistiques descriptives
if (!require("moments")) install.packages("moments")
if (!require("psych")) install.packages("psych")
if (!require("rugarch")) install.packages("rugarch")
if (!require("FinTS")) install.packages("FinTS")




library (tseries)
library(FinTS)
library(rugarch)
library(Metrics)
library(forecast)
library(dplyr)
library(tidyr)
library(lubridate)
library(forecast)
library(tseries)
library(ggplot2)
library(gridExtra)
library(moments)
library(psych)


```


```{r}
ticker <- "EURUSD=X"
getSymbols(ticker, src = "yahoo", from = "2022-01-01", to = "2024-12-31")

# Extraire les prix de clôture
close_prices <- Cl(get(ticker))
cat("Nombre d'observations :", length(close_prices), "\n")
cat("Période :", as.character(start(close_prices)), "à", as.character(end(close_prices)), "\n\n")

# Calculer les rendements logarithmiques (classique pour rendre la série stationnaire en finance)
log_returns <- diff(log(close_prices))
log_returns <- na.omit(log_returns)  # Supprimer les NA

# Statistiques descriptives
cat("Statistiques descriptives des rendements :\n")
cat("  Moyenne :", mean(log_returns), "\n")
cat("  Écart-type :", sd(log_returns), "\n")
cat("  Min :", min(log_returns), "\n")
cat("  Max :", max(log_returns), "\n")
cat("  Skewness :", moments::skewness(as.numeric(log_returns)), "\n")
cat("  Kurtosis :", moments::kurtosis(as.numeric(log_returns)), "\n\n")
class(log_returns) #"xts" "zoo"
log_returns

```


```{r, echo=FALSE}
adf_test <- adf.test(log_returns)


if (adf_test$p.value > 0.05) {
  interpretation_texte <- paste(
    "- p-value ≥ 0.05 → On NE REJETTE PAS H0",
    "- ✗ La série n'est pas stationnaire.",
    sep = "\n"
  )
} else {
  interpretation_texte <- paste(
    "- p-value < 0.05 → On REJETTE H0",
    "- ✓ La série est stationnaire.",
    sep = "\n"
  )
}

texte_final <- paste(
  "INTERPRÉTATION DU TEST ADF :",
  "-----------------------------",
  "- H0 : la série n'est pas Stationnaire",
  interpretation_texte,
  sep = "\n"
)

print(adf_test)

```

```{r, echo=FALSE}
# Test KPSS

kpss_result <- kpss.test(log_returns)

cat("\nTest KPSS sur la série brute :\n")
cat("-------------------------------\n")
cat("Statistique KPSS :", round(kpss_result$statistic, 4), "\n")
cat("p-value :", round(kpss_result$p.value, 4), "\n\n")

if (kpss_result$p.value < 0.05) {
  cat("✗ La série est NON-STATIONNAIRE (p < 0.05)\n")
} else {
  cat("✓ La série est STATIONNAIRE (p ≥ 0.05)\n")
}
```




```{r}
# Visualisation graphique
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))

# Graphique 1 : Prix de clôture
plot(close_prices, main = "Prix de l'Or (GC=F)", ylab = "Prix USD", col = "darkgoldenrod2", lwd = 1.5)

# Graphique 2 : Rendements
plot(log_returns, main = "Rendements Logarithmiques", ylab = "Rendements", col = "steelblue", type = "h")

# Graphique 3 : Rendements au carré (indicateur de volatilité)
plot(log_returns^2, main = "Rendements au Carré (Volatilité)", ylab = "Rendements²", col = "red3", type = "h")

# Graphique 4 : Histogramme des rendements
hist(log_returns, breaks = 50, main = "Distribution des Rendements", 
     xlab = "Rendements", col = "lightblue", border = "white")
```


```{r}
# ACF des rendements
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
acf(log_returns, main = "ACF des Rendements", lag.max = 30)
pacf(log_returns, main = "PACF des Rendements", lag.max = 30)

# ACF des rendements au carré (crucial pour détecter les effets ARCH)
acf(log_returns^2, main = "ACF des Rendements²", lag.max = 30, col = "red")
pacf(log_returns^2, main = "PACF des Rendements²", lag.max = 30, col = "red")

cat("INTERPRÉTATION :\n")
cat("- Si ACF des rendements² montre des autocorrélations significatives,\n")
cat("  cela indique la présence d'hétéroscédasticité (effets ARCH).\n")
cat("- Les pics dans l'ACF des rendements² suggèrent que la volatilité\n")
cat("  passée influence la volatilité actuelle.\n\n")
```


```{r}

cat("--- 1.2 : Tests Formels d'Hétéroscédasticité ---\n\n")

# Test ARCH de Engle (test du multiplicateur de Lagrange)
cat("▶ Test ARCH de Engle (test LM) :\n")
arch_test <- ArchTest(log_returns, lags = 10)
print(arch_test)

cat("\nINTERPRÉTATION du Test ARCH :\n")
cat("- H0 : Pas d'effet ARCH (variance homoscédastique)\n")
cat("- H1 : Présence d'effet ARCH (variance hétéroscédastique)\n")
if (arch_test$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Présence significative d'effets ARCH !\n")
  cat("  → Un modèle ARCH est approprié.\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- CONCLUSION : Pas d'évidence d'effets ARCH significatifs.\n\n")
}

cat("▶ Test de Ljung-Box sur les Rendements :\n")
lb_test <- Box.test(log_returns, type = "Ljung-Box", lag = 30)
print(lb_test)

cat("\nINTERPRÉTATION du Test de Ljung-Box (rendements) :\n")
cat("- H0 : Pas d'autocorrélation dans les rendements\n")
if (lb_test$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Les rendements sont autocorrélés.\n")
  cat("  → Cela confirme l'hétéroscédasticité conditionnelle (effets ARCH).\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n\n")
}

# Test de Ljung-Box sur les rendements au carré
cat("▶ Test de Ljung-Box sur les Rendements² :\n")
lb_test2 <- Box.test(log_returns^2, type = "Ljung-Box", lag = 30)
print(lb_test2)

cat("\nINTERPRÉTATION du Test de Ljung-Box (rendements²) :\n")
cat("- H0 : Pas d'autocorrélation dans les rendements²\n")
if (lb_test2$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Les rendements² sont autocorrélés.\n")
  cat("  → Cela confirme l'hétéroscédasticité conditionnelle (effets ARCH).\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n\n")
}
```
Donc comme le test de Box-Ljung indique que les résidus ne sont pas des bruits blancs on va essayer de trouver un modèle ARIMA qui convienne
```{r}
cat("Sélection automatique du meilleur modèle ARIMA...\n\n")

fit_auto <- auto.arima(log_returns,
                       seasonal = TRUE,
                       stepwise = FALSE,
                       approximation = FALSE,
                       trace = TRUE,
                       ic = "aicc")

cat("\n========================================\n")
cat("MEILLEUR MODÈLE SÉLECTIONNÉ\n")
cat("========================================\n")
print(summary(fit_auto))
```
Pas super le meilleur modèle c'est ARIMA(2,0,3)


```{r}

residus<- residuals(fit_auto)

cat("--- 1.2 : Tests Formels d'Hétéroscédasticité ---\n\n")

# Test ARCH de Engle (test du multiplicateur de Lagrange)
cat("▶ Test ARCH de Engle (test LM) :\n")
arch_test <- ArchTest(residus, lags = 10)
print(arch_test)

cat("\nINTERPRÉTATION du Test ARCH :\n")
cat("- H0 : Pas d'effet ARCH (variance homoscédastique)\n")
cat("- H1 : Présence d'effet ARCH (variance hétéroscédastique)\n")
if (arch_test$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Présence significative d'effets ARCH !\n")
  cat("  → Un modèle ARCH est approprié.\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- CONCLUSION : Pas d'évidence d'effets ARCH significatifs.\n\n")
}

cat("▶ Test de Ljung-Box sur les Rendements :\n")
lb_test <- Box.test(residus, type = "Ljung-Box", lag = 30)
print(lb_test)

cat("\nINTERPRÉTATION du Test de Ljung-Box (rendements) :\n")
cat("- H0 : Pas d'autocorrélation dans les rendements\n")
if (lb_test$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Les rendements sont autocorrélés.\n")
  cat("  → Cela confirme l'hétéroscédasticité conditionnelle (effets ARCH).\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n\n")
}

# Test de Ljung-Box sur les rendements au carré
cat("▶ Test de Ljung-Box sur les Rendements² :\n")
lb_test2 <- Box.test(residus^2, type = "Ljung-Box", lag = 30)
print(lb_test2)

cat("\nINTERPRÉTATION du Test de Ljung-Box (rendements²) :\n")
cat("- H0 : Pas d'autocorrélation dans les rendements²\n")
if (lb_test2$p.value < 0.05) {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- CONCLUSION : Les rendements² sont autocorrélés.\n")
  cat("  → Cela confirme l'hétéroscédasticité conditionnelle (effets ARCH).\n\n")
} else {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n\n")
}
```


```{r}
# Essayer avec différents solveurs et options


spec_arch1 <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 0)),  # ARCH(1) = GARCH(1,0)
  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
  distribution.model = "norm"
)
fit_arch1 <- ugarchfit(spec = spec_arch1, data = residus, solver = "hybrid")

cat("\n========================================\n")
cat("RÉSULTATS DU MODÈLE ARCH(1)\n")
cat("========================================\n")
print(fit_arch1)


# Extraction des coefficients
coefs <- coef(fit_arch1)
cat("\n--- Coefficients Estimés ---\n")
cat("μ (mu)     :", coefs["mu"], "\n")
cat("ω (omega)  :", coefs["omega"], "\n")
cat("α₁ (alpha1):", coefs["alpha1"], "\n\n")

cat("--- Interprétation des Coefficients ---\n\n")

cat("1. ω (omega) = ", coefs["omega"], "\n")
cat("   → Variance inconditionnelle de base.\n")
cat("   → Doit être strictement positif (condition de positivité).\n")
if (coefs["omega"] > 0) {
  cat("   ✓ Condition respectée.\n\n")
} else {
  cat("   ✗ ATTENTION : omega négatif ! Modèle invalide.\n\n")
}

cat("2. α₁ (alpha1) = ", coefs["alpha1"], "\n")
cat("   → Mesure la persistance de la volatilité.\n")
cat("   → Plus α₁ est proche de 1, plus les chocs passés ont un impact durable.\n")
cat("   → Doit être dans [0, 1] pour la stationnarité.\n")
if (coefs["alpha1"] >= 0 && coefs["alpha1"] < 1) {
  cat("   ✓ Condition de stationnarité respectée.\n")
} else if (coefs["alpha1"] >= 1) {
  cat("   ✗ ATTENTION : α₁ ≥ 1, le processus est non-stationnaire !\n")
} else {
  cat("   ✗ ATTENTION : α₁ < 0, condition de positivité non respectée !\n")
}

cat("\n3. Variance Inconditionnelle :\n")
var_incond <- coefs["omega"] / (1 - coefs["alpha1"])
cat("   V(ε_t) = ω / (1 - α₁) = ", var_incond, "\n")
cat("   Écart-type inconditionnel = ", sqrt(var_incond), "\n\n")

# Extraction de la volatilité conditionnelle estimée
sigma_t <- sigma(fit_arch1)

# Graphique de la volatilité conditionnelle
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
plot(log_returns, main = "Rendements de l'Or", ylab = "Rendements", col = "steelblue", type = "h")
plot(sigma_t, main = "Volatilité Conditionnelle Estimée (σ_t)", 
     ylab = "Volatilité", col = "red3", lwd = 1.5)

cat("\nLa volatilité conditionnelle varie dans le temps et capte les périodes\n")
cat("de forte et faible volatilité dans les données.\n\n")
```

```{r}
spec_garch11 <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),  # ARCH(1) = GARCH(1,0)
  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
  distribution.model = "norm"
)
fit_garch11 <- ugarchfit(spec = spec_garch11, data = residus, solver = "hybrid")
print(fit_garch11)

```



```{r}
# -------------------------------------------------------------------------
# 3. ANALYSE DES RÉSIDUS
# -------------------------------------------------------------------------

cat("========================================\n")
cat("ÉTAPE 3 : ANALYSE DES RÉSIDUS\n")
cat("========================================\n\n")

cat("Objectif : Vérifier que le modèle ARCH(1) a bien capturé\n")
cat("           toute l'hétéroscédasticité présente dans les données.\n\n")

# Extraction des résidus standardisés
residus_std <- residuals(fit_arch1, standardize = TRUE)

cat("--- 3.1 : Statistiques Descriptives des Résidus Standardisés ---\n\n")
cat("Les résidus standardisés doivent se comporter comme un bruit blanc :\n")
cat("  - Moyenne proche de 0\n")
cat("  - Écart-type proche de 1\n")
cat("  - Pas d'autocorrélation\n\n")

cat("Moyenne des résidus :", mean(residus_std), "\n")
cat("Écart-type des résidus :", sd(residus_std), "\n")
cat("Min :", min(residus_std), "\n")
cat("Max :", max(residus_std), "\n\n")

# Graphiques diagnostiques
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))

# 1. Résidus standardisés dans le temps
plot(residus_std, main = "Résidus Standardisés", ylab = "Résidus", col = "darkgreen", type = "h")
abline(h = 0, col = "red", lty = 2)

# 2. Histogramme
hist(residus_std, breaks = 50, main = "Distribution des Résidus", 
     xlab = "Résidus Standardisés", col = "lightgreen", border = "white", probability = TRUE)
curve(dnorm(x, mean = mean(residus_std), sd = sd(residus_std)), add = TRUE, col = "red", lwd = 2)

# 3. QQ-plot
qqnorm(residus_std, main = "QQ-Plot des Résidus")
qqline(residus_std, col = "red", lwd = 2)

# 4. Résidus² dans le temps
plot(residus_std^2, main = "Résidus Standardisés au Carré", ylab = "Résidus²", col = "purple", type = "h")

cat("--- 3.2 : Tests d'Autocorrélation des Résidus ---\n\n")

# ACF et PACF des résidus standardisés
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
acf(residus_std, main = "ACF des Résidus Standardisés", lag.max = 30)
pacf(residus_std, main = "PACF des Résidus Standardisés", lag.max = 30)
acf(residus_std^2, main = "ACF des Résidus² Standardisés", lag.max = 30, col = "purple")
pacf(residus_std^2, main = "PACF des Résidus² Standardisés", lag.max = 30, col = "purple")

cat("▶ Test de Ljung-Box sur les Résidus Standardisés :\n")
lb_residus <- Box.test(residus_std, type = "Ljung-Box", lag = 30)
print(lb_residus)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'autocorrélation dans les résidus\n")
if (lb_residus$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Les résidus sont un bruit blanc (pas de structure autocorrélée).\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Il reste de l'autocorrélation dans les résidus.\n")
  cat("  → Le modèle pourrait être amélioré (ARMA + ARCH).\n\n")
}

# Test de Ljung-Box sur les résidus au carré
cat("▶ Test de Ljung-Box sur les Résidus² Standardisés :\n")
lb_residus2 <- Box.test(residus_std^2, type = "Ljung-Box", lag = 30)
print(lb_residus2)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'autocorrélation dans les résidus²\n")
if (lb_residus2$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Le modèle ARCH(1) a bien capturé l'hétéroscédasticité.\n")
  cat("  → Pas d'effet ARCH résiduel détecté.\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Il reste de l'hétéroscédasticité dans les résidus.\n")
  cat("  → Un modèle ARCH d'ordre supérieur ou GARCH pourrait être nécessaire.\n\n")
}

# Test ARCH sur les résidus
cat("▶ Test ARCH sur les Résidus Standardisés :\n")
arch_test_residus <- ArchTest(residus_std, lags = 10)
print(arch_test_residus)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'effet ARCH résiduel\n")
if (arch_test_residus$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Pas d'effet ARCH résiduel ! Le modèle est adéquat.\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Des effets ARCH résiduels persistent.\n")
  cat("  → Envisager un modèle GARCH(p,q) avec p,q > 1.\n\n")
}

cat("========================================\n")
cat("CONCLUSION GÉNÉRALE\n")
cat("========================================\n\n")

cat("1. Les données de l'or présentent de l'hétéroscédasticité conditionnelle,\n")
cat("   ce qui justifie l'utilisation d'un modèle ARCH.\n\n")

cat("2. Le modèle ARCH(1) estime une volatilité conditionnelle qui varie\n")
cat("   dans le temps en fonction des chocs passés.\n\n")

cat("3. L'analyse des résidus permet de valider si le modèle a bien capturé\n")
cat("   toute la structure de dépendance dans la variance.\n\n")

if (lb_residus2$p.value > 0.05 && arch_test_residus$p.value > 0.05) {
  cat("✓ Le modèle ARCH(1) semble ADÉQUAT pour ces données.\n\n")
} else {
  cat("⚠ Le modèle pourrait être amélioré (essayer GARCH(1,1) ou ARCH(p) avec p>1).\n\n")
}

cat("========================================\n")
cat("FIN DE L'ANALYSE\n")
cat("========================================\n")


```

```{r}
# -------------------------------------------------------------------------
# 3. ANALYSE DES RÉSIDUS
# -------------------------------------------------------------------------

cat("========================================\n")
cat("ÉTAPE 3 : ANALYSE DES RÉSIDUS\n")
cat("========================================\n\n")

cat("Objectif : Vérifier que le modèle ARCH(1) a bien capturé\n")
cat("           toute l'hétéroscédasticité présente dans les données.\n\n")

# Extraction des résidus standardisés
residus_std <- residuals(fit_garch11, standardize = TRUE)

cat("--- 3.1 : Statistiques Descriptives des Résidus Standardisés ---\n\n")
cat("Les résidus standardisés doivent se comporter comme un bruit blanc :\n")
cat("  - Moyenne proche de 0\n")
cat("  - Écart-type proche de 1\n")
cat("  - Pas d'autocorrélation\n\n")

cat("Moyenne des résidus :", mean(residus_std), "\n")
cat("Écart-type des résidus :", sd(residus_std), "\n")
cat("Min :", min(residus_std), "\n")
cat("Max :", max(residus_std), "\n\n")

# Graphiques diagnostiques
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))

# 1. Résidus standardisés dans le temps
plot(residus_std, main = "Résidus Standardisés", ylab = "Résidus", col = "darkgreen", type = "h")
abline(h = 0, col = "red", lty = 2)

# 2. Histogramme
hist(residus_std, breaks = 50, main = "Distribution des Résidus", 
     xlab = "Résidus Standardisés", col = "lightgreen", border = "white", probability = TRUE)
curve(dnorm(x, mean = mean(residus_std), sd = sd(residus_std)), add = TRUE, col = "red", lwd = 2)

# 3. QQ-plot
qqnorm(residus_std, main = "QQ-Plot des Résidus")
qqline(residus_std, col = "red", lwd = 2)

# 4. Résidus² dans le temps
plot(residus_std^2, main = "Résidus Standardisés au Carré", ylab = "Résidus²", col = "purple", type = "h")

cat("--- 3.2 : Tests d'Autocorrélation des Résidus ---\n\n")

# ACF et PACF des résidus standardisés
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
acf(residus_std, main = "ACF des Résidus Standardisés", lag.max = 30)
pacf(residus_std, main = "PACF des Résidus Standardisés", lag.max = 30)
acf(residus_std^2, main = "ACF des Résidus² Standardisés", lag.max = 30, col = "purple")
pacf(residus_std^2, main = "PACF des Résidus² Standardisés", lag.max = 30, col = "purple")

cat("▶ Test de Ljung-Box sur les Résidus Standardisés :\n")
lb_residus <- Box.test(residus_std, type = "Ljung-Box", lag = 30)
print(lb_residus)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'autocorrélation dans les résidus\n")
if (lb_residus$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Les résidus sont un bruit blanc (pas de structure autocorrélée).\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Il reste de l'autocorrélation dans les résidus.\n")
  cat("  → Le modèle pourrait être amélioré (ARMA + ARCH).\n\n")
}

# Test de Ljung-Box sur les résidus au carré
cat("▶ Test de Ljung-Box sur les Résidus² Standardisés :\n")
lb_residus2 <- Box.test(residus_std^2, type = "Ljung-Box", lag = 30)
print(lb_residus2)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'autocorrélation dans les résidus²\n")
if (lb_residus2$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Le modèle ARCH(1) a bien capturé l'hétéroscédasticité.\n")
  cat("  → Pas d'effet ARCH résiduel détecté.\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Il reste de l'hétéroscédasticité dans les résidus.\n")
  cat("  → Un modèle ARCH d'ordre supérieur ou GARCH pourrait être nécessaire.\n\n")
}

# Test ARCH sur les résidus
cat("▶ Test ARCH sur les Résidus Standardisés :\n")
arch_test_residus <- ArchTest(residus_std, lags = 10)
print(arch_test_residus)

cat("\nINTERPRÉTATION :\n")
cat("- H0 : Pas d'effet ARCH résiduel\n")
if (arch_test_residus$p.value > 0.05) {
  cat("- p-value ≥ 0.05 → On NE REJETTE PAS H0\n")
  cat("- ✓ Pas d'effet ARCH résiduel ! Le modèle est adéquat.\n\n")
} else {
  cat("- p-value < 0.05 → On REJETTE H0\n")
  cat("- ✗ Des effets ARCH résiduels persistent.\n")
  cat("  → Envisager un modèle GARCH(p,q) avec p,q > 1.\n\n")
}

cat("========================================\n")
cat("CONCLUSION GÉNÉRALE\n")
cat("========================================\n\n")

cat("1. Les données de l'or présentent de l'hétéroscédasticité conditionnelle,\n")
cat("   ce qui justifie l'utilisation d'un modèle ARCH.\n\n")

cat("2. Le modèle ARCH(1) estime une volatilité conditionnelle qui varie\n")
cat("   dans le temps en fonction des chocs passés.\n\n")

cat("3. L'analyse des résidus permet de valider si le modèle a bien capturé\n")
cat("   toute la structure de dépendance dans la variance.\n\n")

if (lb_residus2$p.value > 0.05 && arch_test_residus$p.value > 0.05) {
  cat("✓ Le modèle ARCH(1) semble ADÉQUAT pour ces données.\n\n")
} else {
  cat("⚠ Le modèle pourrait être amélioré (essayer GARCH(1,1) ou ARCH(p) avec p>1).\n\n")
}

cat("========================================\n")
cat("FIN DE L'ANALYSE\n")
cat("========================================\n")

```


