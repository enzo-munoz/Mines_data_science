---
title: "Analyse EUR/USD : M√©thodologie de Box-Jenkins avec mod√©lisation ARIMA-GARCH"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
date: "2025-10-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width = 10, fig.height = 6)
```

# Introduction

Ce document pr√©sente une analyse compl√®te du taux de change EUR/USD en suivant la **m√©thodologie de Box-Jenkins** :

1. **Identification** : Tests de stationnarit√© et analyse des autocorr√©lations
2. **Estimation** : S√©lection automatique du meilleur mod√®le ARIMA
3. **Validation** : Tests sur les r√©sidus (Ljung-Box, ARCH)
4. **Mod√©lisation de la volatilit√©** : Si n√©cessaire, ajout d'un mod√®le GARCH
5. **It√©rations** : Am√©lioration progressive jusqu'√† obtenir un mod√®le ad√©quat

```{r packages}
# Chargement des packages
packages <- c("quantmod", "tseries", "forecast", "rugarch", "FinTS", 
              "dplyr", "tidyr", "lubridate", "ggplot2", "gridExtra", 
              "moments", "psych", "knitr", "kableExtra")

for (pkg in packages) {
  if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
    install.packages(pkg, quiet = TRUE)
    library(pkg, character.only = TRUE, quietly = TRUE)
  }
}
```
```{r packages}


library (tseries)
library(FinTS)
library(rugarch)
library(Metrics)
library(forecast)
library(dplyr)
library(tidyr)
library(lubridate)
library(forecast)
library(tseries)
library(ggplot2)
library(gridExtra)
library(moments)
library(psych)
```


# 1. Collecte et Pr√©paration des Donn√©es

```{r data_collection}
ticker <- "EURUSD=X"
getSymbols(ticker, src = "yahoo", from = "2022-01-01", to = "2024-12-31", auto.assign = TRUE)

log_returns <- diff(log(close_prices))
log_returns <- na.omit(log_returns)

# Statistiques descriptives
stats_desc <- data.frame(
  Statistique = c("Nombre d'observations", "Moyenne", "√âcart-type", "Minimum", 
                  "Maximum", "Skewness", "Kurtosis"),
  Valeur = c(
    length(log_returns),
    round(mean(log_returns), 6),
    round(sd(log_returns), 6),
    round(min(log_returns), 6),
    round(max(log_returns), 6),
    round(moments::skewness(as.numeric(log_returns)), 4),
    round(moments::kurtosis(as.numeric(log_returns)), 4)
  )
)

kable(stats_desc, caption = "Statistiques Descriptives des Rendements Logarithmiques") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

**Interpr√©tation** : Les rendements montrent une moyenne proche de z√©ro (caract√©ristique des s√©ries financi√®res), une volatilit√© mod√©r√©e, et un kurtosis sup√©rieur √† 3 sugg√©rant des queues √©paisses (comportement typique des actifs financiers).

# 2. √âtape 1 : Identification - Tests de Stationnarit√©

```{r stationarity_tests}
# Test ADF
adf_result <- adf.test(log_returns)
adf_stationnaire <- adf_result$p.value < 0.05

# Test KPSS
kpss_result <- kpss.test(log_returns)
kpss_stationnaire <- kpss_result$p.value >= 0.05

tests_stationnarite <- data.frame(
  Test = c("Augmented Dickey-Fuller (ADF)", "KPSS"),
  Statistique = c(round(adf_result$statistic, 4), round(kpss_result$statistic, 4)),
  `P-value` = c(round(adf_result$p.value, 4), round(kpss_result$p.value, 4)),
  Conclusion = c(
    ifelse(adf_stationnaire, "‚úì Stationnaire", "‚úó Non-stationnaire"),
    ifelse(kpss_stationnaire, "‚úì Stationnaire", "‚úó Non-stationnaire")
  )
)

kable(tests_stationnarite, caption = "Tests de Stationnarit√©") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

**Rappel th√©orique** : 
- **ADF** : H‚ÇÄ = pr√©sence de racine unitaire (non-stationnarit√©)
- **KPSS** : H‚ÇÄ = stationnarit√©

**Conclusion** : `r if(adf_stationnaire && kpss_stationnaire) "Les deux tests confirment la stationnarit√© de la s√©rie. Nous pouvons proc√©der √† la mod√©lisation ARMA." else "La s√©rie n√©cessite une diff√©renciation."`

```{r visualisation_series}
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
plot(close_prices, main = "EUR/USD - Prix de Cl√¥ture", ylab = "Taux de Change", col = "darkblue", lwd = 1.5)
plot(log_returns, main = "Rendements Logarithmiques", ylab = "Rendements", col = "steelblue", type = "h")
plot(log_returns^2, main = "Rendements au Carr√© (Proxy de Volatilit√©)", ylab = "Rendements¬≤", col = "red3", type = "h")
hist(log_returns, breaks = 50, main = "Distribution des Rendements", 
     xlab = "Rendements", col = "lightblue", border = "white", probability = TRUE)
lines(density(log_returns), col = "red", lwd = 2)
```

# 3. √âtape 2 : Identification - Analyse des Autocorr√©lations

```{r acf_pacf}
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
acf(log_returns, main = "ACF des Rendements", lag.max = 30)
pacf(log_returns, main = "PACF des Rendements", lag.max = 30)
acf(log_returns^2, main = "ACF des Rendements¬≤ (Volatilit√©)", lag.max = 30, col = "red")
pacf(log_returns^2, main = "PACF des Rendements¬≤", lag.max = 30, col = "red")
```

**Observation** : Si l'ACF des rendements¬≤ montre des pics significatifs, cela indique la pr√©sence d'**h√©t√©rosc√©dasticit√© conditionnelle** (effets ARCH/GARCH).

# 4. √âtape 3 : Estimation - S√©lection du Mod√®le ARIMA

```{r arima_selection}

fit_arima <- auto.arima(log_returns,
                        seasonal = FALSE,
                        stepwise = FALSE,
                        approximation = FALSE,
                        ic = "aicc",
                        trace = FALSE)

arima_order <- arimaorder(fit_arima)
arima_results <- data.frame(
  Crit√®re = c("Ordre ARIMA", "AIC", "AICc", "BIC", "Log-Likelihood"),
  Valeur = c(
    paste0("ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")"),
    round(AIC(fit_arima), 2),
    round(fit_arima$aicc, 2),
    round(BIC(fit_arima), 2),
    round(fit_arima$loglik, 2)
  )
)

kable(arima_results, caption = "R√©sultats du Meilleur Mod√®le ARIMA") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

cat("\n")
print(summary(fit_arima))
```

# 5. √âtape 4 : Validation - Tests sur les R√©sidus du Mod√®le ARIMA

```{r residuals_arima}
residus_arima <- residuals(fit_arima)

# Test de Ljung-Box sur les r√©sidus
lb_residus <- Box.test(residus_arima, type = "Ljung-Box", lag = 40)

# Test de Ljung-Box sur les r√©sidus¬≤
lb_residus2 <- Box.test(residus_arima^2, type = "Ljung-Box", lag = 40)

# Test ARCH
arch_test <- ArchTest(residus_arima, lags = 10)

tests_residus <- data.frame(
  Test = c("Ljung-Box (r√©sidus)", "Ljung-Box (r√©sidus¬≤)", "ARCH (Engle)"),
  Statistique = c(round(lb_residus$statistic, 4), round(lb_residus2$statistic, 4), 
                  round(arch_test$statistic, 4)),
  `P-value` = c(round(lb_residus$p.value, 4), round(lb_residus2$p.value, 4), 
                round(arch_test$p.value, 4)),
  Hypoth√®se_H0 = c("Pas d'autocorr√©lation", "Pas d'autocorr√©lation", "Pas d'effet ARCH"),
  D√©cision = c(
    ifelse(lb_residus$p.value > 0.05, "‚úì H‚ÇÄ accept√©e", "‚úó H‚ÇÄ rejet√©e"),
    ifelse(lb_residus2$p.value > 0.05, "‚úì H‚ÇÄ accept√©e", "‚úó H‚ÇÄ rejet√©e"),
    ifelse(arch_test$p.value > 0.05, "‚úì H‚ÇÄ accept√©e", "‚úó H‚ÇÄ rejet√©e")
  )
)

kable(tests_residus, caption = "Tests de Diagnostic sur les R√©sidus ARIMA") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

**Interpr√©tation** :

- **Ljung-Box sur r√©sidus** : `r if(lb_residus$p.value > 0.05) "‚úì Les r√©sidus sont un bruit blanc, le mod√®le ARIMA capture bien la dynamique moyenne." else "‚úó Il reste de l'autocorr√©lation, le mod√®le ARIMA pourrait √™tre am√©lior√©."`

- **Ljung-Box sur r√©sidus¬≤** : `r if(lb_residus2$p.value > 0.05) "‚úì Pas d'h√©t√©rosc√©dasticit√© d√©tect√©e." else "‚úó Pr√©sence d'h√©t√©rosc√©dasticit√© conditionnelle."`

- **Test ARCH** : `r if(arch_test$p.value > 0.05) "‚úì Pas d'effet ARCH, un mod√®le GARCH n'est pas n√©cessaire." else "‚úó Effets ARCH d√©tect√©s, il faut mod√©liser la volatilit√© avec GARCH."`

```{r plot_residus_arima}
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
plot(residus_arima, main = "R√©sidus du Mod√®le ARIMA", ylab = "R√©sidus", col = "darkgreen", type = "h")
abline(h = 0, col = "red", lty = 2)
hist(residus_arima, breaks = 50, main = "Distribution des R√©sidus", 
     xlab = "R√©sidus", col = "lightgreen", border = "white", probability = TRUE)
curve(dnorm(x, mean = mean(residus_arima), sd = sd(residus_arima)), add = TRUE, col = "red", lwd = 2)
qqnorm(residus_arima, main = "QQ-Plot des R√©sidus")
qqline(residus_arima, col = "red", lwd = 2)
acf(residus_arima^2, main = "ACF des R√©sidus¬≤", lag.max = 30, col = "purple")
```

# 6. √âtape 5 : Mod√©lisation GARCH (si n√©cessaire)

```{r garch_modeling, results='asis'}
if (arch_test$p.value < 0.05) {
  cat("\n## 6.1 D√©tection d'Effets ARCH : Mod√©lisation de la Volatilit√©\n\n")
  cat("Le test ARCH a r√©v√©l√© la pr√©sence d'**h√©t√©rosc√©dasticit√© conditionnelle**. ")
  cat("Nous allons maintenant tester plusieurs sp√©cifications de mod√®les GARCH.\n\n")
  
  # Liste des mod√®les √† tester
  models_list <- list(
    list(name = "GARCH(1,1)", model = "sGARCH", order = c(1,1)),
    list(name = "GARCH(1,2)", model = "sGARCH", order = c(1,2)),
    list(name = "GARCH(2,1)", model = "sGARCH", order = c(2,1)),
    list(name = "TGARCH(1,1)", model = "fGARCH", submodel = "TGARCH", order = c(1,1)),
    list(name = "EGARCH(1,1)", model = "eGARCH", order = c(1,1)),
    list(name = "GJR-GARCH(1,1)", model = "gjrGARCH", order = c(1,1))
  )
  
  results_garch <- data.frame()
  fitted_models <- list()
  
  for (i in seq_along(models_list)) {
    model_spec <- models_list[[i]]
    
    tryCatch({
      if (model_spec$model == "fGARCH") {
        spec <- ugarchspec(
          variance.model = list(model = model_spec$model, 
                                submodel = model_spec$submodel,
                                garchOrder = model_spec$order),
          mean.model = list(armaOrder = c(arima_order[1], arima_order[3]), 
                            include.mean = TRUE),
          distribution.model = "norm"
        )
      } else {
        spec <- ugarchspec(
          variance.model = list(model = model_spec$model, 
                                garchOrder = model_spec$order),
          mean.model = list(armaOrder = c(arima_order[1], arima_order[3]), 
                            include.mean = TRUE),
          distribution.model = "norm"
        )
      }
      
      fit <- ugarchfit(spec = spec, data = log_returns, solver = "hybrid")
      
      fitted_models[[model_spec$name]] <- fit
      
      results_garch <- rbind(results_garch, data.frame(
        Mod√®le = model_spec$name,
        AIC = round(infocriteria(fit)[1], 4),
        BIC = round(infocriteria(fit)[2], 4),
        Log_Likelihood = round(likelihood(fit), 4),
        Convergence = ifelse(convergence(fit) == 0, "‚úì", "‚úó")
      ))
    }, error = function(e) {
      results_garch <<- rbind(results_garch, data.frame(
        Mod√®le = model_spec$name,
        AIC = NA,
        BIC = NA,
        Log_Likelihood = NA,
        Convergence = "Erreur"
      ))
    })
  }
  
  results_garch <- results_garch[order(results_garch$AIC, na.last = TRUE), ]
  
  cat("\n### Comparaison des Mod√®les GARCH\n\n")
  kable(results_garch, caption = "Comparaison des Crit√®res d'Information (class√©s par AIC)") %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
    print()
  
  # S√©lection du meilleur mod√®le
  best_model_name <- results_garch$Mod√®le[1]
  best_fit <- fitted_models[[best_model_name]]
  
  cat("\n### Meilleur Mod√®le S√©lectionn√© : **", best_model_name, "**\n\n")
  
  cat("```\n")
  print(best_fit)
  cat("```\n\n")
  
  # Analyse des r√©sidus du mod√®le GARCH
  cat("\n## 6.2 Validation du Mod√®le GARCH\n\n")
  
  residus_std_garch <- residuals(best_fit, standardize = TRUE)
  
  lb_garch <- Box.test(residus_std_garch, type = "Ljung-Box", lag = 40)
  lb_garch2 <- Box.test(residus_std_garch^2, type = "Ljung-Box", lag = 40)
  arch_garch <- ArchTest(residus_std_garch, lags = 10)
  
  tests_garch <- data.frame(
    Test = c("Ljung-Box (r√©sidus std.)", "Ljung-Box (r√©sidus¬≤ std.)", "ARCH (r√©sidus std.)"),
    Statistique = c(round(lb_garch$statistic, 4), round(lb_garch2$statistic, 4), 
                    round(arch_garch$statistic, 4)),
    `P-value` = c(round(lb_garch$p.value, 4), round(lb_garch2$p.value, 4), 
                  round(arch_garch$p.value, 4)),
    D√©cision = c(
      ifelse(lb_garch$p.value > 0.05, "‚úì Pas d'autocorr√©lation", "‚úó Autocorr√©lation r√©siduelle"),
      ifelse(lb_garch2$p.value > 0.05, "‚úì Pas d'h√©t√©rosc√©dasticit√©", "‚úó H√©t√©rosc√©dasticit√© r√©siduelle"),
      ifelse(arch_garch$p.value > 0.05, "‚úì Pas d'effet ARCH", "‚úó Effet ARCH r√©siduel")
    )
  )
  
  kable(tests_garch, caption = "Tests de Diagnostic sur les R√©sidus Standardis√©s du Mod√®le GARCH") %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
    print()
  
  cat("\n### Graphiques de Diagnostic\n\n")
  
  par(mfrow = c(2, 3), mar = c(4, 4, 3, 1))
  
  plot(residus_std_garch, main = "R√©sidus Standardis√©s", ylab = "R√©sidus", 
       col = "darkgreen", type = "h")

  hist(residus_std_garch, breaks = 50, main = "Distribution des R√©sidus Std.", 
       xlab = "R√©sidus", col = "lightgreen", border = "white", probability = TRUE)
  curve(dnorm(x), add = TRUE, col = "red", lwd = 2)
  
  qqnorm(residus_std_garch, main = "QQ-Plot")
  qqline(residus_std_garch, col = "red", lwd = 2)
  
  acf(residus_std_garch, main = "ACF R√©sidus Std.", lag.max = 30)
  acf(residus_std_garch^2, main = "ACF R√©sidus¬≤ Std.", lag.max = 30, col = "purple")
  
  sigma_t <- sigma(best_fit)
  plot(sigma_t, main = "Volatilit√© Conditionnelle œÉ(t)", 
       ylab = "Volatilit√©", col = "red3", lwd = 1.5)
  
  cat("\n**Interpr√©tation finale** :\n\n")
  
  if (lb_garch2$p.value > 0.05 && arch_garch$p.value > 0.05) {
    cat("‚úì Le mod√®le **", best_model_name, "** a correctement captur√© l'h√©t√©rosc√©dasticit√© conditionnelle. ")
    cat("Les r√©sidus standardis√©s sont un bruit blanc, et il n'y a plus d'effet ARCH r√©siduel.\n\n")
    cat("‚úì **Le mod√®le est valid√© et peut √™tre utilis√© pour la pr√©vision.**\n\n")
  } else {
    cat("‚ö† Le mod√®le ", best_model_name, " pr√©sente encore des effets ARCH r√©siduels ou de l'autocorr√©lation. ")
    cat("Des mod√®les d'ordre sup√©rieur ou avec d'autres distributions (Student-t, GED) pourraient am√©liorer l'ajustement.\n\n")
  }
  
} else {
  cat("\n## 6.1 Aucun Effet ARCH D√©tect√©\n\n")
  cat("Le test ARCH n'a pas r√©v√©l√© d'h√©t√©rosc√©dasticit√© conditionnelle significative. ")
  cat("Le mod√®le ARIMA seul est suffisant pour mod√©liser la s√©rie.\n\n")
  cat("‚úì **Mod√®le final retenu : ", paste0("ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")"), "**\n\n")
}
```

# 7. Conclusion et Synth√®se de la M√©thodologie

```{r conclusion, results='asis'}
cat("\n## R√©sum√© de la D√©marche de Box-Jenkins Appliqu√©e\n\n")

cat("### √âtape 1 : Identification\n")
cat("- Tests de stationnarit√© (ADF, KPSS) ‚Üí S√©rie stationnaire confirm√©e\n")
cat("- Analyse ACF/PACF ‚Üí Identification des ordres potentiels p et q\n\n")

cat("### √âtape 2 : Estimation\n")
cat("- S√©lection automatique du meilleur mod√®le ARIMA via auto.arima()\n")
cat("- Crit√®re de s√©lection : AICc (corrig√© pour les petits √©chantillons)\n")
cat("- Mod√®le retenu : **", paste0("ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")"), "**\n\n")

cat("### √âtape 3 : Validation (r√©sidus ARIMA)\n")
cat("- Test de Ljung-Box sur les r√©sidus ‚Üí V√©rification du bruit blanc\n")
cat("- Test de Ljung-Box sur les r√©sidus¬≤ ‚Üí D√©tection d'h√©t√©rosc√©dasticit√©\n")
cat("- Test ARCH ‚Üí Confirmation de l'effet ARCH\n\n")

if (arch_test$p.value < 0.05) {
  cat("### √âtape 4 : Mod√©lisation de la Volatilit√©\n")
  cat("- Pr√©sence d'effets ARCH/GARCH d√©tect√©e\n")
  cat("- Comparaison syst√©matique de 6 sp√©cifications :\n")
  cat("  - GARCH(1,1), GARCH(1,2), GARCH(2,1)\n")
  cat("  - TGARCH(1,1), EGARCH(1,1), GJR-GARCH(1,1)\n")
  cat("- S√©lection du meilleur mod√®le selon l'AIC\n")
  cat("- Meilleur mod√®le : **", best_model_name, "**\n\n")
  
  cat("### √âtape 5 : Validation Finale\n")
  cat("- Tests sur les r√©sidus standardis√©s du mod√®le GARCH\n")
  cat("- V√©rification de l'absence d'effet ARCH r√©siduel\n")
  if (lb_garch2$p.value > 0.05 && arch_garch$p.value > 0.05) {
    cat("- ‚úì **Mod√®le valid√© : ARIMA(", arima_order[1], ",", arima_order[2], ",", 
        arima_order[3], ") + ", best_model_name, "**\n\n")
  } else {
    cat("- ‚ö† Des am√©liorations suppl√©mentaires sont possibles\n\n")
  }
} else {
  cat("### √âtape 4 : Mod√®le Final\n")
  cat("- Pas d'h√©t√©rosc√©dasticit√© d√©tect√©e\n")
  cat("- ‚úì **Mod√®le final valid√© : ARIMA(", arima_order[1], ",", arima_order[2], ",", 
      arima_order[3], ")**\n\n")
}

```

# Introduction

Ce document pr√©sente une analyse **it√©rative compl√®te** du taux de change EUR/USD suivant la **m√©thodologie de Box-Jenkins √©tendue** :

**Processus it√©ratif** (jusqu'√† 50 it√©rations) :
1. Estimer ARIMA sur les donn√©es (ou r√©sidus de l'it√©ration pr√©c√©dente)
2. Tester les r√©sidus ARIMA pour effets ARCH
3. Si effets ARCH ‚Üí Estimer GARCH, sinon ‚Üí STOP
4. Extraire les r√©sidus standardis√©s du mod√®le complet
5. **Recommencer avec ces r√©sidus** comme nouvelle s√©rie
6. Continuer jusqu'√† : convergence (plus d'effets ARCH) OU 50 it√©rations

```{r packages}
packages <- c("quantmod", "tseries", "forecast", "rugarch", "FinTS", 
              "dplyr", "tidyr", "lubridate", "ggplot2", "gridExtra", 
              "moments", "psych", "knitr", "kableExtra")

for (pkg in packages) {
  if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
    install.packages(pkg, quiet = TRUE)
    library(pkg, character.only = TRUE, quietly = TRUE)
  }
}
```

# 1. Collecte et Pr√©paration des Donn√©es

```{r data_collection}
ticker <- "EURUSD=X"
getSymbols(ticker, src = "yahoo", from = "2022-01-01", to = "2024-12-31", auto.assign = TRUE)

close_prices <- Cl(get(ticker))
log_returns <- diff(log(close_prices))
log_returns <- na.omit(log_returns)

stats_desc <- data.frame(
  Statistique = c("Nombre d'observations", "Moyenne", "√âcart-type", "Minimum", 
                  "Maximum", "Skewness", "Kurtosis"),
  Valeur = c(
    length(log_returns),
    round(mean(log_returns), 6),
    round(sd(log_returns), 6),
    round(min(log_returns), 6),
    round(max(log_returns), 6),
    round(moments::skewness(as.numeric(log_returns)), 4),
    round(moments::kurtosis(as.numeric(log_returns)), 4)
  )
)

kable(stats_desc, caption = "Statistiques Descriptives des Rendements Logarithmiques") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

```{r visualisation_initiale}
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
plot(close_prices, main = "EUR/USD - Prix de Cl√¥ture", ylab = "Taux de Change", col = "darkblue", lwd = 1.5)
plot(log_returns, main = "Rendements Logarithmiques", ylab = "Rendements", col = "steelblue", type = "h")
plot(log_returns^2, main = "Rendements¬≤ (Proxy Volatilit√©)", ylab = "Rendements¬≤", col = "red3", type = "h")
hist(log_returns, breaks = 50, main = "Distribution des Rendements", 
     xlab = "Rendements", col = "lightblue", border = "white", probability = TRUE)
lines(density(log_returns), col = "red", lwd = 2)
```

# 2. Tests de Stationnarit√© Initiaux

```{r stationarity}
adf_result <- adf.test(log_returns)
kpss_result <- kpss.test(log_returns)

tests_stationnarite <- data.frame(
  Test = c("Augmented Dickey-Fuller", "KPSS"),
  Statistique = c(round(adf_result$statistic, 4), round(kpss_result$statistic, 4)),
  `P-value` = c(round(adf_result$p.value, 4), round(kpss_result$p.value, 4)),
  Conclusion = c(
    ifelse(adf_result$p.value < 0.05, "‚úì Stationnaire", "‚úó Non-stationnaire"),
    ifelse(kpss_result$p.value >= 0.05, "‚úì Stationnaire", "‚úó Non-stationnaire")
  )
)

kable(tests_stationnarite, caption = "Tests de Stationnarit√©") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

# 3. Processus It√©ratif Complet (Max 50 it√©rations)

```{r iteration_complete, results='asis'}
# Initialisation
serie_courante <- log_returns
max_iterations <- 50
convergence <- FALSE
iteration <- 0

# Stockage des r√©sultats
historique_iterations <- data.frame()
modeles_estimes <- list()

cat("\n## Journal des It√©rations\n\n")
cat("**Principe** : √Ä chaque it√©ration, on teste si les r√©sidus n√©cessitent un nouveau cycle ARIMA-GARCH.\n\n")
cat("---\n\n")

while (iteration < max_iterations && !convergence) {
  iteration <- iteration + 1
  
  cat("### IT√âRATION ", iteration, "\n\n")
  
  # ==========================================
  # √âTAPE 1 : ESTIMATION ARIMA
  # ==========================================
  
  cat("#### √âtape 1.", iteration, ".A - Estimation ARIMA\n\n")
  
  fit_arima <- auto.arima(serie_courante,
                          seasonal = FALSE,
                          stepwise = FALSE,
                          approximation = FALSE,
                          ic = "aicc",
                          trace = FALSE)
  
  arima_order <- arimaorder(fit_arima)
  cat("- Mod√®le s√©lectionn√© : **ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")**\n")
  cat("- AICc = ", round(fit_arima$aicc, 2), "\n\n")
  
  residus_arima <- residuals(fit_arima)
  
  # ==========================================
  # √âTAPE 2 : TESTS SUR R√âSIDUS ARIMA
  # ==========================================
  
  cat("#### √âtape 1.", iteration, ".B - Tests sur r√©sidus ARIMA\n\n")
  
  lb_residus <- Box.test(residus_arima, type = "Ljung-Box", lag = 40)
  lb_residus2 <- Box.test(residus_arima^2, type = "Ljung-Box", lag = 40)
  arch_test <- ArchTest(residus_arima, lags = 10)
  
  tests_iter <- data.frame(
    Test = c("Ljung-Box (r√©sidus)", "Ljung-Box (r√©sidus¬≤)", "ARCH"),
    `P-value` = c(round(lb_residus$p.value, 4), round(lb_residus2$p.value, 4), 
                  round(arch_test$p.value, 4)),
    D√©cision = c(
      ifelse(lb_residus$p.value > 0.05, "‚úì OK", "‚úó Autocorr√©lation"),
      ifelse(lb_residus2$p.value > 0.05, "‚úì OK", "‚úó H√©t√©rosc√©dasticit√©"),
      ifelse(arch_test$p.value > 0.05, "‚úì OK", "‚úó Effet ARCH")
    )
  )
  
  print(kable(tests_iter, caption = paste("Tests It√©ration", iteration)) %>%
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE))
  
  cat("\n")
  
  # ==========================================
  # D√âCISION : GARCH N√âCESSAIRE ?
  # ==========================================
  
  if (arch_test$p.value < 0.05) {
    cat("**D√©cision** : Effet ARCH d√©tect√© (p = ", round(arch_test$p.value, 4), ") ‚Üí **Estimation GARCH**\n\n")
    
    # ==========================================
    # √âTAPE 3 : ESTIMATION GARCH
    # ==========================================
    
    cat("#### √âtape 1.", iteration, ".C - Comparaison mod√®les GARCH\n\n")
    
    models_list <- list(
      list(name = "GARCH(1,1)", model = "sGARCH", order = c(1,1)),
      list(name = "GARCH(1,2)", model = "sGARCH", order = c(1,2)),
      list(name = "GARCH(2,1)", model = "sGARCH", order = c(2,1)),
      list(name = "TGARCH(1,1)", model = "fGARCH", submodel = "TGARCH", order = c(1,1)),
      list(name = "EGARCH(1,1)", model = "eGARCH", order = c(1,1)),
      list(name = "GJR-GARCH(1,1)", model = "gjrGARCH", order = c(1,1))
    )
    
    results_garch <- data.frame()
    fitted_models <- list()
    
    for (i in seq_along(models_list)) {
      model_spec <- models_list[[i]]
      
      tryCatch({
        if (model_spec$model == "fGARCH") {
          spec <- ugarchspec(
            variance.model = list(model = model_spec$model, 
                                  submodel = model_spec$submodel,
                                  garchOrder = model_spec$order),
            mean.model = list(armaOrder = c(arima_order[1], arima_order[3]), 
                              include.mean = TRUE),
            distribution.model = "norm"
          )
        } else {
          spec <- ugarchspec(
            variance.model = list(model = model_spec$model, 
                                  garchOrder = model_spec$order),
            mean.model = list(armaOrder = c(arima_order[1], arima_order[3]), 
                              include.mean = TRUE),
            distribution.model = "norm"
          )
        }
        
        fit <- ugarchfit(spec = spec, data = serie_courante, solver = "hybrid")
        
        fitted_models[[model_spec$name]] <- fit
        
        results_garch <- rbind(results_garch, data.frame(
          Mod√®le = model_spec$name,
          AIC = round(infocriteria(fit)[1], 4),
          BIC = round(infocriteria(fit)[2], 4),
          Convergence = ifelse(convergence(fit) == 0, "‚úì", "‚úó")
        ))
      }, error = function(e) {
        results_garch <<- rbind(results_garch, data.frame(
          Mod√®le = model_spec$name,
          AIC = NA,
          BIC = NA,
          Convergence = "Erreur"
        ))
      })
    }
    
    results_garch <- results_garch[order(results_garch$AIC, na.last = TRUE), ]
    
    print(kable(results_garch, caption = paste("Comparaison GARCH - It√©ration", iteration)) %>%
      kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE))
    
    cat("\n")
    
    best_model_name <- results_garch$Mod√®le[1]
    best_fit <- fitted_models[[best_model_name]]
    
    cat("- **Meilleur mod√®le** : ", best_model_name, " (AIC = ", round(results_garch$AIC[1], 2), ")\n\n")
    
    # ==========================================
    # √âTAPE 4 : VALIDATION MOD√àLE GARCH
    # ==========================================
    
    cat("#### √âtape 1.", iteration, ".D - Validation mod√®le complet\n\n")
    
    residus_std_garch <- residuals(best_fit, standardize = TRUE)
    
    lb_garch <- Box.test(residus_std_garch, type = "Ljung-Box", lag = 40)
    lb_garch2 <- Box.test(residus_std_garch^2, type = "Ljung-Box", lag = 40)
    arch_garch <- ArchTest(residus_std_garch, lags = 10)
    
    tests_garch_iter <- data.frame(
      Test = c("Ljung-Box (r√©sidus std.)", "Ljung-Box (r√©sidus¬≤ std.)", "ARCH (r√©sidus std.)"),
      `P-value` = c(round(lb_garch$p.value, 4), round(lb_garch2$p.value, 4), 
                    round(arch_garch$p.value, 4)),
      D√©cision = c(
        ifelse(lb_garch$p.value > 0.05, "‚úì OK", "‚úó Autocorr√©lation"),
        ifelse(lb_garch2$p.value > 0.05, "‚úì OK", "‚úó H√©t√©rosc√©dasticit√©"),
        ifelse(arch_garch$p.value > 0.05, "‚úì OK", "‚úó Effet ARCH")
      )
    )
    
    print(kable(tests_garch_iter, caption = paste("Validation GARCH - It√©ration", iteration)) %>%
      kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE))
    
    cat("\n")
    
    # Enregistrement
    historique_iterations <- rbind(historique_iterations, data.frame(
      Iteration = iteration,
      Modele_ARIMA = paste0("ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")"),
      Modele_GARCH = best_model_name,
      ARCH_pvalue = round(arch_garch$p.value, 4),
      LB_residus2_pvalue = round(lb_garch2$p.value, 4),
      Convergence_atteinte = ifelse(arch_garch$p.value > 0.05 && lb_garch2$p.value > 0.05, "OUI", "NON")
    ))
    
    modeles_estimes[[paste0("Iter_", iteration)]] <- list(
      arima = fit_arima,
      garch = best_fit,
      residus = residus_std_garch
    )
    
    # ==========================================
    # D√âCISION DE CONVERGENCE
    # ==========================================
    
    if (arch_garch$p.value > 0.05 && lb_garch2$p.value > 0.05) {
      cat("**CONVERGENCE ATTEINTE** : Plus d'effet ARCH r√©siduel !\n\n")
      cat("Mod√®le final : **ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], 
          ") + ", best_model_name, "**\n\n")
      convergence <- TRUE
    } else {
      cat("Effets r√©siduels d√©tect√©s ‚Üí **It√©ration suivante n√©cessaire**\n\n")
      cat("Les r√©sidus standardis√©s deviennent la nouvelle s√©rie √† mod√©liser\n\n")
      serie_courante <- residus_std_garch
    }
    
  } else {
    cat("**D√©cision** : Pas d'effet ARCH (p = ", round(arch_test$p.value, 4), ") ‚Üí **ARIMA seul suffit**\n\n")
    
    historique_iterations <- rbind(historique_iterations, data.frame(
      Iteration = iteration,
      Modele_ARIMA = paste0("ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")"),
      Modele_GARCH = "Aucun",
      ARCH_pvalue = round(arch_test$p.value, 4),
      LB_residus2_pvalue = round(lb_residus2$p.value, 4),
      Convergence_atteinte = "OUI"
    ))
    
    modeles_estimes[[paste0("Iter_", iteration)]] <- list(
      arima = fit_arima,
      garch = NULL,
      residus = residus_arima
    )
    
    cat("**CONVERGENCE ATTEINTE** : Mod√®le ARIMA seul est ad√©quat !\n\n")
    cat("Mod√®le final : **ARIMA(", arima_order[1], ",", arima_order[2], ",", arima_order[3], ")**\n\n")
    convergence <- TRUE
  }
  
  cat("---\n\n")
}

# ==========================================
# SYNTH√àSE FINALE
# ==========================================

cat("# 4. Synth√®se du Processus It√©ratif\n\n")

if (convergence) {
  cat("**Convergence atteinte apr√®s ", iteration, " it√©ration(s)**\n\n")
} else {
  cat("**Maximum d'it√©rations atteint (50) sans convergence compl√®te**\n\n")
}

print(kable(historique_iterations, caption = "Historique Complet des It√©rations") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  column_spec(6, bold = TRUE, color = ifelse(historique_iterations$Convergence_atteinte == "OUI", "green", "red")))

cat("\n")
```

# 5. Analyse D√©taill√©e du Mod√®le Final

```{r analyse_finale, results='asis'}
modele_final <- modeles_estimes[[paste0("Iter_", iteration)]]

cat("## 5.1 Sp√©cification du Mod√®le Final\n\n")

if (!is.null(modele_final$garch)) {
  cat("**Mod√®le complet retenu** : ARIMA-GARCH combin√©\n\n")
  cat("```\n")
  print(modele_final$garch)
  cat("```\n\n")
} else {
  cat("**Mod√®le retenu** : ARIMA seul\n\n")
  cat("```\n")
  print(summary(modele_final$arima))
  cat("```\n\n")
}

cat("## 5.2 Analyse Graphique des R√©sidus Finaux\n\n")

residus_finaux <- modele_final$residus

par(mfrow = c(3, 2), mar = c(4, 4, 3, 1))

# S√©rie temporelle
plot(residus_finaux, main = "R√©sidus Finaux Standardis√©s", ylab = "R√©sidus", 
     col = "darkgreen", type = "h")
abline(h = 0, col = "red", lty = 2)

# Histogramme
hist(residus_finaux, breaks = 50, main = "Distribution des R√©sidus", 
     xlab = "R√©sidus", col = "lightgreen", border = "white", probability = TRUE)
curve(dnorm(x, mean = mean(residus_finaux), sd = sd(residus_finaux)), 
      add = TRUE, col = "red", lwd = 2)

# QQ-plot
qqnorm(residus_finaux, main = "QQ-Plot")
qqline(residus_finaux, col = "red", lwd = 2)

# ACF
acf(residus_finaux, main = "ACF des R√©sidus", lag.max = 30)

# ACF r√©sidus¬≤
acf(residus_finaux^2, main = "ACF des R√©sidus¬≤", lag.max = 30, col = "purple")

# Volatilit√© (si GARCH)
if (!is.null(modele_final$garch)) {
  sigma_finale <- sigma(modele_final$garch)
  plot(sigma_finale, main = "Volatilit√© Conditionnelle Finale", 
       ylab = "œÉ(t)", col = "red3", lwd = 1.5)
} else {
  plot(residus_finaux^2, main = "Carr√©s des R√©sidus", 
       ylab = "R√©sidus¬≤", col = "purple", type = "h")
}

cat("\n## 5.3 Tests de Diagnostic Finaux\n\n")

lb_final <- Box.test(residus_finaux, type = "Ljung-Box", lag = 40)
lb_final2 <- Box.test(residus_finaux^2, type = "Ljung-Box", lag = 40)
arch_final <- ArchTest(residus_finaux, lags = 10)

tests_finaux <- data.frame(
  Test = c("Ljung-Box (r√©sidus)", "Ljung-Box (r√©sidus¬≤)", "ARCH"),
  Statistique = c(round(lb_final$statistic, 4), round(lb_final2$statistic, 4), 
                  round(arch_final$statistic, 4)),
  `P-value` = c(round(lb_final$p.value, 4), round(lb_final2$p.value, 4), 
                round(arch_final$p.value, 4)),
  Interpr√©tation = c(
    ifelse(lb_final$p.value > 0.05, "‚úì R√©sidus = bruit blanc", "‚úó Autocorr√©lation r√©siduelle"),
    ifelse(lb_final2$p.value > 0.05, "‚úì Pas d'h√©t√©rosc√©dasticit√©", "‚úó H√©t√©rosc√©dasticit√© r√©siduelle"),
    ifelse(arch_final$p.value > 0.05, "‚úì Pas d'effet ARCH", "‚úó Effet ARCH r√©siduel")
  )
)

print(kable(tests_finaux, caption = "Tests de Diagnostic sur le Mod√®le Final") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE))

cat("\n")
```

# 6. Conclusion et Interpr√©tation M√©thodologique

```{r conclusion, results='asis'}
cat("## R√©sum√© de la D√©marche It√©rative\n\n")

cat("### Principe de l'Approche It√©rative\n\n")

cat("Contrairement √† une approche classique o√π l'on s'arr√™te apr√®s avoir trouv√© un mod√®le ARIMA-GARCH, ")
cat("cette m√©thodologie **it√©rative** consid√®re que les r√©sidus standardis√©s peuvent encore contenir ")
cat("de l'information structur√©e non captur√©e.\n\n")

cat("**Algorithme appliqu√©** :\n\n")
cat("1. **Initialisation** : S√©rie = rendements EUR/USD\n")
cat("2. **Boucle** (max 50 it√©rations) :\n")
cat("   - Estimer ARIMA sur la s√©rie courante\n")
cat("   - Tester effets ARCH sur r√©sidus ARIMA\n")
cat("   - Si ARCH d√©tect√© :\n")
cat("     - Comparer 6 sp√©cifications GARCH\n")
cat("     - S√©lectionner le meilleur (AIC)\n")
cat("     - Tester r√©sidus standardis√©s\n")
cat("     - Si encore ARCH ‚Üí r√©sidus deviennent nouvelle s√©rie\n")
cat("   - Si pas ARCH ‚Üí CONVERGENCE\n")
cat("3. **Arr√™t** : Convergence OU 50 it√©rations\n\n")

cat("### R√©sultats Obtenus\n\n")

cat("- **Nombre d'it√©rations n√©cessaires** : ", iteration, "\n")
cat("- **Convergence** : ", ifelse(convergence, "OUI", "NON"), "\n")

if (iteration == 1) {
  cat("- **Interpr√©tation** : La s√©rie √©tait d√©j√† bien mod√©lis√©e d√®s la premi√®re it√©ration. ")
  cat("Les r√©sidus ne contenaient pas de structure additionnelle.\n\n")
} else if (iteration <= 5) {
  cat("- **Interpr√©tation** : Quelques it√©rations ont √©t√© n√©cessaires pour affiner le mod√®le. ")
  cat("Cela sugg√®re que la dynamique de volatilit√© √©tait complexe.\n\n")
} else {
  cat("- **Interpr√©tation** : Un nombre √©lev√© d'it√©rations sugg√®re soit une tr√®s forte complexit√©, ")
  cat("soit une instabilit√© num√©rique. V√©rifier la qualit√© des estimations.\n\n")
}

cat("### Avantages de Cette Approche\n\n")
cat("1. **Exhaustivit√©** : On s'assure qu'aucune structure n'est laiss√©e dans les r√©sidus\n")
cat("2. **Robustesse** : D√©tection automatique de patterns cach√©s\n")
cat("3. **Objectivit√©** : D√©cisions guid√©es par tests statistiques √† chaque √©tape\n")
cat("4. **Tra√ßabilit√©** : Historique complet document√©\n\n")

cat("### Limites et Pr√©cautions\n\n")
cat("1. **Sur-ajustement** : Trop d'it√©rations peut conduire √† mod√©liser du bruit\n")
cat("2. **Stabilit√© num√©rique** : Les estimations peuvent devenir instables\n")
cat("3. **Interpr√©tation** : Un mod√®le complexe peut perdre en interpr√©tabilit√©\n\n")

cat("---\n\n")
cat("**Conclusion finale** : ")
if (convergence && all(historique_iterations$Convergence_atteinte[iteration] == "OUI")) {
  cat(" Le processus it√©ratif a permis d'obtenir un mod√®le optimal o√π tous les tests ")
  cat("de diagnostic sont satisfaits. Le mod√®le final peut √™tre utilis√© pour la pr√©vision.\n")
} else {
  cat("‚ö† Le mod√®le n√©cessite une validation suppl√©mentaire ou des ajustements (distribution Student-t, ")
  cat("mod√®les d'ordre sup√©rieur, etc.).\n")
}
```


```{r prevision_2025, results='asis'}
cat("## 7.1 Donn√©es R√©elles de Janvier 2025\n\n")

# R√©cup√©ration des donn√©es r√©elles de janvier 2025
getSymbols(ticker, src = "yahoo", from = "2025-01-01", to = "2025-01-10", auto.assign = TRUE)
real_2025 <- Cl(get(ticker))
real_2025 <- na.omit(real_2025)

cat("- **P√©riode de validation** : Premi√®re semaine de janvier 2025\n")
cat("- **Nombre de jours** : ", length(real_2025), " observations\n\n")

# Conversion en rendements
real_returns_2025 <- diff(log(real_2025))
real_returns_2025 <- na.omit(real_returns_2025)

donnees_reelles <- data.frame(
  Date = index(real_returns_2025),
  Prix = as.numeric(real_2025[-1]),
  Rendement = as.numeric(real_returns_2025) * 100  # en %
)

print(kable(donnees_reelles, 
            caption = "Donn√©es R√©elles - Premi√®re Semaine de Janvier 2025",
            digits = 5,
            col.names = c("Date", "Prix EUR/USD", "Rendement (%)")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE))

cat("\n\n")

cat("## 7.2 Pr√©visions du Mod√®le Final\n\n")

n_ahead <- length(real_returns_2025)

if (!is.null(modele_final$garch)) {
  # Pr√©vision avec mod√®le GARCH
  cat("**M√©thode** : Pr√©vision avec le mod√®le ARIMA-GARCH complet\n\n")
  
  # Utiliser les donn√©es originales pour la pr√©vision
  spec_final <- getspec(modele_final$garch)
  
  # R√©-estimer sur toute la p√©riode d'entra√Ænement
  fit_final_full <- ugarchfit(spec = spec_final, data = log_returns, solver = "hybrid")
  
  # Pr√©vision
  forecast_garch <- ugarchforecast(fit_final_full, n.ahead = n_ahead)
  
  # Extraire les pr√©visions
  prev_rendements <- as.numeric(fitted(forecast_garch))
  prev_sigma <- as.numeric(sigma(forecast_garch))
  
  # Intervalles de confiance (95%)
  ic_inf <- prev_rendements - 1.96 * prev_sigma
  ic_sup <- prev_rendements + 1.96 * prev_sigma
  
} else {
  # Pr√©vision avec mod√®le ARIMA seul
  cat("**M√©thode** : Pr√©vision avec le mod√®le ARIMA seul\n\n")
  
  forecast_arima <- forecast(modele_final$arima, h = n_ahead)
  
  prev_rendements <- as.numeric(forecast_arima$mean)
  ic_inf <- as.numeric(forecast_arima$lower[, 2])  # IC 95%
  ic_sup <- as.numeric(forecast_arima$upper[, 2])
  prev_sigma <- (ic_sup - ic_inf) / (2 * 1.96)
}

# Cr√©er le dataframe de comparaison
dates_prev <- index(real_returns_2025)

comparaison <- data.frame(
  Date = dates_prev,
  R√©el = as.numeric(real_returns_2025) * 100,
  Pr√©vision = prev_rendements * 100,
  IC_inf = ic_inf * 100,
  IC_sup = ic_sup * 100,
  Erreur = (as.numeric(real_returns_2025) - prev_rendements) * 100,
  Erreur_pct = abs((as.numeric(real_returns_2025) - prev_rendements) / 
                     as.numeric(real_returns_2025)) * 100
)

print(kable(comparaison, 
            caption = "Comparaison Pr√©visions vs R√©alisations",
            digits = 4,
            col.names = c("Date", "R√©el (%)", "Pr√©vu (%)", "IC Inf (%)", 
                         "IC Sup (%)", "Erreur (%)", "Erreur Rel. (%)")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")))

cat("\n\n")

cat("## 7.3 M√©triques de Performance\n\n")

# Calcul des m√©triques
mae <- mean(abs(comparaison$Erreur))
rmse <- sqrt(mean(comparaison$Erreur^2))
mape <- mean(abs(comparaison$Erreur_pct), na.rm = TRUE)

# Proportion dans IC 95%
dans_ic <- sum(comparaison$R√©el >= comparaison$IC_inf & 
               comparaison$R√©el <= comparaison$IC_sup)
taux_couverture <- (dans_ic / n_ahead) * 100

# Test de Diebold-Mariano (si assez de donn√©es)
if (n_ahead >= 5) {
  dm_test <- tryCatch({
    # Erreurs du mod√®le na√Øf (random walk)
    erreurs_naif <- diff(as.numeric(real_2025))[-1]
    erreurs_modele <- comparaison$Erreur / 100
    
    dm.test(erreurs_modele, erreurs_naif, alternative = "less")
  }, error = function(e) NULL)
}

metriques <- data.frame(
  M√©trique = c("MAE (Mean Absolute Error)", 
               "RMSE (Root Mean Squared Error)", 
               "MAPE (Mean Absolute % Error)",
               "Taux de Couverture IC 95%"),
  Valeur = c(
    paste0(round(mae, 4), " %"),
    paste0(round(rmse, 4), " %"),
    paste0(round(mape, 2), " %"),
    paste0(round(taux_couverture, 1), " % (", dans_ic, "/", n_ahead, ")")
  ),
  Interpr√©tation = c(
    ifelse(mae < 0.5, "‚úì Excellent", ifelse(mae < 1, "‚úì Bon", "‚ö† Moyen")),
    ifelse(rmse < 0.5, "‚úì Excellent", ifelse(rmse < 1, "‚úì Bon", "‚ö† Moyen")),
    ifelse(mape < 50, "‚úì Acceptable", "‚ö† √âlev√©"),
    ifelse(taux_couverture >= 90, "‚úì Excellent", 
           ifelse(taux_couverture >= 80, "‚úì Bon", "‚ö† Sous-couverture"))
  )
)

print(kable(metriques, caption = "M√©triques de Performance Pr√©dictive") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE))

cat("\n\n")

cat("## 7.4 Visualisation Graphique\n\n")

# Graphique principal : Rendements
par(mfrow = c(2, 1), mar = c(4, 4.5, 3, 2))

# Graphique 1 : Rendements pr√©vus vs r√©els
plot(dates_prev, comparaison$R√©el, 
     type = "o", pch = 19, col = "darkblue", lwd = 2,
     xlab = "Date", ylab = "Rendement (%)",
     main = "Pr√©visions vs R√©alisations - Rendements EUR/USD (Janvier 2025)",
     ylim = range(c(comparaison$IC_inf, comparaison$IC_sup, comparaison$R√©el)),
     xaxt = "n")

# Ajouter les dates en x
axis(1, at = dates_prev, labels = format(dates_prev, "%d/%m"), las = 2, cex.axis = 0.8)

# Intervalle de confiance
polygon(c(dates_prev, rev(dates_prev)), 
        c(comparaison$IC_sup, rev(comparaison$IC_inf)),
        col = rgb(0.5, 0.5, 0.5, 0.3), border = NA)

# Pr√©visions
lines(dates_prev, comparaison$Pr√©vision, col = "red2", lwd = 2, lty = 2)
points(dates_prev, comparaison$Pr√©vision, pch = 17, col = "red2", cex = 1.2)

# L√©gende
legend("topright", 
       legend = c("Valeurs R√©elles", "Pr√©visions", "IC 95%"),
       col = c("darkblue", "red2", rgb(0.5, 0.5, 0.5, 0.5)),
       lwd = c(2, 2, 8),
       lty = c(1, 2, 1),
       pch = c(19, 17, NA),
       bg = "white",
       cex = 0.9)

# Ligne z√©ro
abline(h = 0, col = "gray50", lty = 3)

# Graphique 2 : Erreurs de pr√©vision
plot(dates_prev, comparaison$Erreur,
     type = "h", col = ifelse(comparaison$Erreur > 0, "darkgreen", "darkred"),
     lwd = 3, xlab = "Date", ylab = "Erreur de Pr√©vision (%)",
     main = "Erreurs de Pr√©vision (R√©el - Pr√©vu)",
     xaxt = "n")

axis(1, at = dates_prev, labels = format(dates_prev, "%d/%m"), las = 2, cex.axis = 0.8)

points(dates_prev, comparaison$Erreur, 
       pch = 19, 
       col = ifelse(comparaison$Erreur > 0, "darkgreen", "darkred"),
       cex = 1.5)

abline(h = 0, col = "black", lwd = 2)
abline(h = c(-0.5, 0.5), col = "orange", lty = 2)

text(dates_prev, comparaison$Erreur, 
     labels = round(comparaison$Erreur, 2),
     pos = ifelse(comparaison$Erreur > 0, 3, 1),
     cex = 0.7, col = "black")

cat("\n\n")

# Graphique bonus : Prix EUR/USD
par(mfrow = c(1, 1), mar = c(4, 4.5, 3, 2))

# Reconstituer les prix pr√©vus √† partir des rendements
dernier_prix <- as.numeric(tail(close_prices, 1))
prix_prevus <- numeric(n_ahead)
prix_prevus[1] <- dernier_prix * exp(prev_rendements[1])

if (n_ahead > 1) {
  for (i in 2:n_ahead) {
    prix_prevus[i] <- prix_prevus[i-1] * exp(prev_rendements[i])
  }
}

prix_reels <- as.numeric(real_2025[-1])

plot(dates_prev, prix_reels,
     type = "o", pch = 19, col = "darkblue", lwd = 2,
     xlab = "Date", ylab = "Prix EUR/USD",
     main = "Pr√©vision des Prix EUR/USD - Janvier 2025",
     ylim = range(c(prix_reels, prix_prevus)),
     xaxt = "n")

axis(1, at = dates_prev, labels = format(dates_prev, "%d/%m"), las = 2, cex.axis = 0.8)

lines(dates_prev, prix_prevus, col = "red2", lwd = 2, lty = 2)
points(dates_prev, prix_prevus, pch = 17, col = "red2", cex = 1.2)

legend("topleft",
       legend = c("Prix R√©els", "Prix Pr√©vus"),
       col = c("darkblue", "red2"),
       lwd = 2,
       lty = c(1, 2),
       pch = c(19, 17),
       bg = "white")

# Ajouter les valeurs
text(dates_prev, prix_reels, 
     labels = round(prix_reels, 4),
     pos = 3, cex = 0.6, col = "darkblue")

cat("\n\n")

cat("## 7.5 Interpr√©tation des R√©sultats\n\n")

cat("### Performance du Mod√®le\n\n")

if (mae < 0.5 && taux_couverture >= 90) {
  cat("**Excellente performance** : Le mod√®le pr√©dit avec pr√©cision les mouvements de l'EUR/USD. ")
  cat("Les erreurs sont faibles et les intervalles de confiance sont bien calibr√©s.\n\n")
} else if (mae < 1 && taux_couverture >= 80) {
  cat("‚úì **Bonne performance** : Le mod√®le capture la tendance g√©n√©rale m√™me si quelques pr√©visions ")
  cat("s'√©cartent des valeurs r√©alis√©es. Les intervalles de confiance sont globalement fiables.\n\n")
} else {
  cat("‚ö† **Performance mitig√©e** : Le mod√®le montre des limites sur cette p√©riode de validation. ")
  cat("Cela peut √™tre d√ª √† des √©v√©nements exceptionnels ou √† une sp√©cification sous-optimale.\n\n")
}

cat("### Analyse des Erreurs\n\n")

erreurs_positives <- sum(comparaison$Erreur > 0)
erreurs_negatives <- sum(comparaison$Erreur < 0)

cat("- **Erreurs positives** (sous-estimation) : ", erreurs_positives, " / ", n_ahead, "\n")
cat("- **Erreurs n√©gatives** (sur-estimation) : ", erreurs_negatives, " / ", n_ahead, "\n\n")

if (abs(erreurs_positives - erreurs_negatives) <= 1) {
  cat("‚úì Les erreurs sont **√©quilibr√©es** : pas de biais syst√©matique de sur/sous-estimation.\n\n")
} else if (erreurs_positives > erreurs_negatives) {
  cat("‚ö† **Biais √† la sous-estimation** : Le mod√®le a tendance √† pr√©dire des rendements inf√©rieurs aux r√©alisations.\n\n")
} else {
  cat("‚ö† **Biais √† la sur-estimation** : Le mod√®le a tendance √† pr√©dire des rendements sup√©rieurs aux r√©alisations.\n\n")
}

cat("### Limites de la Validation\n\n")

cat("- **Horizon court** : ", n_ahead, " jours de pr√©vision constituent un √©chantillon limit√©\n")
cat("- **P√©riode sp√©cifique** : Janvier 2025 peut pr√©senter des caract√©ristiques particuli√®res\n")
cat("- **Validation robuste** : Il faudrait tester sur plusieurs p√©riodes (rolling forecast)\n\n")
```

```{r}
spec_final <- getspec(modele_final$garch)
  
  # R√©-estimer sur toute la p√©riode d'entra√Ænement
fit_final_full <- ugarchfit(spec = spec_final, data = log_returns, solver = "hybrid")
fit_final_full
```
```{r}
set.seed(123)
n<- length(log_returns)
horizon<- 7

train <- window(log_returns, end = time(des_data)[n-horizon])
test <- window(log_returns, start = time(des_data)[n-horizon+1])

# ----------------------------------------------------
#   Sp√©cification du mod√®le ARIMA(2,0,3) + EGARCH(1,1)
# ----------------------------------------------------
spec_final <- ugarchspec(
  variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
  mean.model     = list(armaOrder = c(2,3), include.mean = TRUE),
  distribution.model = "norm"
)

# ----------------------------------------------------
#   Estimation du mod√®le sur la partie train
# ----------------------------------------------------
modele <- ugarchfit(spec = spec_final, data = train)
# ----------------------------------------------------
#   Pr√©vision au jour le jour sur la s√©rie test
# ----------------------------------------------------
# On pr√©dit une √©tape √† la fois et on met √† jour le mod√®le √† chaque fois

prev <- ugarchforecast(modele, n.ahead=horizon)


# ----------------------------------------------------
#   Intervalles de confiance (√† 95%)
# ----------------------------------------------------
alpha <- 0.05
z <- qnorm(1 - alpha / 2)
ic_sup <- prev_mean + z * prev_sigma
ic_inf <- prev_mean - z * prev_sigma



alpha <- 0.05
z <- qnorm(1-alpha/2)

prev_moy <- as.numeric(fitted(prev))
prev_sigma <- as.numeric(sigma(prev))
ic_sup <- prev_moy + z*prev_sigma
ic_inf <- prev_moy - z*prev_sigma
frequency(train)
start_prev <- tsp(train)[2] + 1/frequency(train)
prev_ts <- ts(prev_moy, frequency=1,
             start = start_prev)
ic_sup_ts <- ts(ic_sup, frequency=7, start = start_prev)
ic_inf_ts <- ts(ic_inf, frequency=7, start = start_prev)

ts.plot(log_returns, col="black", main="Pr√©visions ARMA(5,5)-GARCH(1,1) avec IC √† 95%")
lines(prev_ts, col="blue", lwd=2)
lines(ic_inf_ts, col="red", lty=2)
lines(ic_sup_ts, col="red", lty=2)


des_data_zoom <- window(des_data, start = c(2020, 1))

ylim_vals_ARMA_GARCH <- range(des_data_zoom,
                        prev_ts,
                        ic_inf_ts,
                        ic_sup_ts,
                        na.rm=TRUE)

ts.plot(des_data_zoom, col="black", 
        main="Pr√©visions ARMA(5,5)-GARCH(1,1) avec IC √† 95%", ylim=ylim_vals_ARMA_GARCH)
lines(prev_ts, col="blue")
lines(ic_inf_ts, col="red", lty=2)
lines(ic_sup_ts, col="red", lty=2)

mse <- mse(as.numeric(test), prev_moy)
mae <- mae(as.numeric(test), prev_moy)

cat("MSE : ", mse, "\n",
    "MAE : ", mae)

```

```{r}


# Si ta s√©rie n‚Äôest pas encore au format ts :
des_data <- ts(as.numeric(log_returns), frequency = 365)

# ----------------------------------------------------
#   Split 80/20 avec gestion des dates
# ----------------------------------------------------
n <- length(des_data)
horizon <- floor(0.2 * n)

# Entrainement = 80 % des donn√©es
train <- window(des_data, end = time(des_data)[n - horizon])
# Test = 20 % des donn√©es
test  <- window(des_data, start = time(des_data)[n - horizon + 1])

# ----------------------------------------------------
# üß† Sp√©cification du mod√®le ARIMA(2,0,3) + EGARCH(1,1)
# ----------------------------------------------------
spec_final <- ugarchspec(
  variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
  mean.model     = list(armaOrder = c(2,3), include.mean = TRUE),
  distribution.model = "norm"
)

# ----------------------------------------------------
#   Estimation du mod√®le sur la partie train
# ----------------------------------------------------
modele <- ugarchfit(spec = spec_final, data = train)

# ----------------------------------------------------
#   r√©visions jour par jour sur la s√©rie test
# ----------------------------------------------------
n_forecast <- length(test)
prev_mean <- numeric(n_forecast)
prev_sigma <- numeric(n_forecast)

for (i in 1:n_forecast) {
  # Fit r√©cursif : on met √† jour le mod√®le avec les donn√©es disponibles jusqu‚Äô√† i
  fit_temp <- ugarchfit(spec = spec_final, data = des_data[1:(n - horizon + i - 1)], solver = "hybrid", silent = TRUE)
  f_temp <- ugarchforecast(fit_temp, n.ahead = 1)
  prev_mean[i] <- as.numeric(fitted(f_temp))
  prev_sigma[i] <- as.numeric(sigma(f_temp))
}

# ----------------------------------------------------
#   Intervalles de confiance √† 95 %
# ----------------------------------------------------
alpha <- 0.05
z <- qnorm(1 - alpha / 2)
ic_sup <- prev_mean + z * prev_sigma
ic_inf <- prev_mean - z * prev_sigma

# ----------------------------------------------------
#   Trac√© des pr√©visions avec IC
# ----------------------------------------------------
start_prev <- time(des_data)[n - horizon + 1]
prev_ts <- ts(prev_mean, start = start_prev, frequency = 365)
ic_sup_ts <- ts(ic_sup, start = start_prev, frequency = 365)
ic_inf_ts <- ts(ic_inf, start = start_prev, frequency = 365)

ts.plot(des_data, col = "black", lwd = 1.5,
        main = "Pr√©visions journali√®res ARIMA(2,0,3)-EGARCH(1,1) avec IC √† 95%",
        ylab = "Valeurs", xlab = "Date")
lines(prev_ts, col = "blue", lwd = 2)
lines(ic_sup_ts, col = "red", lty = 2)
lines(ic_inf_ts, col = "red", lty = 2)
abline(v = time(des_data)[n - horizon], col = "gray", lwd = 2, lty = 3)
legend("topleft", legend = c("Train/Test", "Pr√©vision", "IC 95%"),
       col = c("black", "blue", "red"), lty = c(1,1,2), bty = "n")

```


